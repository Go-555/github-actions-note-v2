name: Note Post via MCP

on:
  workflow_dispatch:
    inputs:
      target_folder:
        description: 'æŠ•ç¨¿ã™ã‚‹noteé…ä¸‹ã®ãƒ•ã‚©ãƒ«ãƒ€å (ä¾‹: exsample)'
        required: true
        type: string
      post_type:
        description: 'æŠ•ç¨¿ã‚¿ã‚¤ãƒ—'
        required: true
        type: choice
        options:
          - draft
          - publish
        default: draft
      thumbnail_name:
        description: 'ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç”»åƒã€ä¾‹: sample-thumbnail.pngï¼‰'
        required: false
        type: string

jobs:
  post-to-note:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Validate target folder
        run: |
          TARGET_PATH="note/${{ github.event.inputs.target_folder }}"
          if [ ! -d "$TARGET_PATH" ]; then
            echo "âŒ Error: Folder $TARGET_PATH does not exist"
            exit 1
          fi
          
          # mdãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
          MD_FILE=$(find "$TARGET_PATH" -maxdepth 1 -name "*.md" -type f | head -n 1)
          if [ -z "$MD_FILE" ]; then
            echo "âŒ Error: No markdown file found in $TARGET_PATH"
            exit 1
          fi
          
          echo "âœ… Found markdown file: $MD_FILE"
          echo "MD_FILE=$MD_FILE" >> $GITHUB_ENV
          echo "TARGET_PATH=$TARGET_PATH" >> $GITHUB_ENV

      - name: Setup authentication state
        run: |
          echo '${{ secrets.NOTE_STATE_JSON }}' > ~/.note-state.json
          if [ ! -s ~/.note-state.json ]; then
            echo "âŒ Error: NOTE_STATE_JSON secret is empty"
            echo "Please set NOTE_STATE_JSON secret in repository settings"
            echo "Run 'npm run login' locally to generate the state file"
            exit 1
          fi
          echo "âœ… Authentication state file created"

      - name: Determine thumbnail path
        run: |
          if [ -n "${{ github.event.inputs.thumbnail_name }}" ]; then
            THUMBNAIL_PATH="${{ env.TARGET_PATH }}/${{ github.event.inputs.thumbnail_name }}"
            if [ -f "$THUMBNAIL_PATH" ]; then
              echo "THUMBNAIL_PATH=$THUMBNAIL_PATH" >> $GITHUB_ENV
              echo "âœ… Using thumbnail: $THUMBNAIL_PATH"
            else
              echo "âš ï¸  Warning: Specified thumbnail not found: $THUMBNAIL_PATH"
            fi
          fi

      - name: Get Playwright version
        id: playwright-version
        run: |
          PLAYWRIGHT_VERSION=$(node -p "require('./package-lock.json').packages['node_modules/playwright'].version")
          echo "version=$PLAYWRIGHT_VERSION" >> $GITHUB_OUTPUT
          echo "Playwright version: $PLAYWRIGHT_VERSION"

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ steps.playwright-version.outputs.version }}

      - name: Install dependencies
        run: |
          npm install
          echo "âœ… Dependencies installed"

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: |
          npx playwright install chromium
          npx playwright install-deps chromium
          echo "âœ… Playwright browsers installed"

      - name: Skip Playwright install (using cache)
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: |
          echo "âœ… Using cached Playwright browsers"

      - name: Create posting script
        run: |
          cat > ./post-script.mjs << 'EOFSCRIPT'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import path from 'path';

          // parseMarkdowné–¢æ•°
          function parseMarkdown(content) {
            const lines = content.split('\n');
            let title = '';
            let body = '';
            const tags = [];
            let inFrontMatter = false;
            let frontMatterEnded = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              if (line.trim() === '---') {
                if (!frontMatterEnded) {
                  inFrontMatter = !inFrontMatter;
                  if (!inFrontMatter) {
                    frontMatterEnded = true;
                  }
                  continue;
                }
              }

              if (inFrontMatter) {
                if (line.startsWith('title:')) {
                  title = line.substring(6).trim().replace(/^["']|["']$/g, '');
                } else if (line.startsWith('tags:')) {
                  const tagsStr = line.substring(5).trim();
                  if (tagsStr.startsWith('[') && tagsStr.endsWith(']')) {
                    tags.push(...tagsStr.slice(1, -1).split(',').map(t => t.trim().replace(/^["']|["']$/g, '')));
                  }
                } else if (line.trim().startsWith('-')) {
                  const tag = line.trim().substring(1).trim().replace(/^["']|["']$/g, '');
                  if (tag) tags.push(tag);
                }
                continue;
              }

              if (!title && line.startsWith('# ')) {
                title = line.substring(2).trim();
                continue;
              }

              if (frontMatterEnded || !line.trim().startsWith('---')) {
                body += line + '\n';
              }
            }

            return {
              title: title || 'Untitled',
              body: body.trim(),
              tags: tags.filter(Boolean),
            };
          }

          // ç”»åƒæŠ½å‡ºé–¢æ•°
          function extractImages(markdown, baseDir) {
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            const images = [];
            let match;

            while ((match = imageRegex.exec(markdown)) !== null) {
              const alt = match[1] || 'image';
              const imagePath = match[2];
              
              if (!imagePath.startsWith('http://') && !imagePath.startsWith('https://')) {
                const absolutePath = path.resolve(baseDir, imagePath);
                if (fs.existsSync(absolutePath)) {
                  images.push({
                    alt,
                    localPath: imagePath,
                    absolutePath,
                    placeholder: match[0],
                  });
                }
              }
            }

            return images;
          }

          // ãƒ¡ã‚¤ãƒ³å‡¦ç†
          async function main() {
            const markdownPath = process.env.MD_FILE;
            const thumbnailPath = process.env.THUMBNAIL_PATH || '';
            const isPublic = process.env.POST_TYPE === 'publish';
            const statePath = path.join(process.env.HOME, '.note-state.json');

            console.log('ğŸ“ Starting note.com post...');
            console.log('  Markdown:', markdownPath);
            console.log('  Thumbnail:', thumbnailPath || 'None');
            console.log('  Type:', isPublic ? 'Publish' : 'Draft');

            const mdContent = fs.readFileSync(markdownPath, 'utf-8');
            const { title, body, tags } = parseMarkdown(mdContent);
            const baseDir = path.dirname(markdownPath);
            const images = extractImages(body, baseDir);

            console.log('  Title:', title);
            console.log('  Tags:', tags.join(', '));
            console.log('  Images:', images.length);

            const browser = await chromium.launch({
              headless: true,
              args: ['--lang=ja-JP', '--no-sandbox', '--disable-setuid-sandbox'],
            });

            const context = await browser.newContext({
              storageState: statePath,
              locale: 'ja-JP',
              permissions: ['clipboard-read', 'clipboard-write'],
            });

            const page = await context.newPage();
            page.setDefaultTimeout(180000);

            await context.grantPermissions(['clipboard-read', 'clipboard-write'], { 
              origin: 'https://editor.note.com' 
            });

            try {
              console.log('ğŸŒ Navigating to editor...');
              await page.goto('https://editor.note.com/new', { 
                waitUntil: 'domcontentloaded',
                timeout: 180000 
              });
              
              console.log('â³ Waiting for editor to load...');
              await page.waitForSelector('textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]', { timeout: 180000 });
              console.log('âœ… Editor loaded successfully');
            } catch (error) {
              console.error('âŒ Failed to load editor page');
              console.error('Error:', error.message);
              
              // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ’®å½±
              const screenshotPath = 'error-screenshot.png';
              await page.screenshot({ path: screenshotPath, fullPage: true });
              console.log(`ğŸ“¸ Screenshot saved: ${screenshotPath}`);
              
              // ç¾åœ¨ã®URLã‚’è¡¨ç¤º
              console.log('Current URL:', page.url());
              
              // ãƒšãƒ¼ã‚¸ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¡¨ç¤º
              const pageTitle = await page.title();
              console.log('Page Title:', pageTitle);
              
              await browser.close();
              throw error;
            }

            // ã‚µãƒ ãƒã‚¤ãƒ«å‡¦ç†ï¼ˆç°¡ç•¥ç‰ˆï¼‰
            if (thumbnailPath && fs.existsSync(thumbnailPath)) {
              console.log('ğŸ–¼ï¸  Uploading thumbnail...');
              try {
                const addBtn = page.locator('button[aria-label="ç”»åƒã‚’è¿½åŠ "]').first();
                await addBtn.waitFor({ state: 'visible', timeout: 10000 });
                await addBtn.click();

                const uploadBtn = page.locator('button:has-text("ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰")').first();
                await uploadBtn.waitFor({ state: 'visible', timeout: 10000 });

                const fileInput = page.locator('input[type="file"]').first();
                await fileInput.setInputFiles(thumbnailPath);

                await page.waitForTimeout(2000);

                const dialog = page.locator('div[role="dialog"]');
                const saveBtn = dialog.locator('button:has-text("ä¿å­˜")').first();
                await saveBtn.waitFor({ state: 'visible', timeout: 10000 });
                await page.waitForTimeout(1000);
                await saveBtn.click();
                await page.waitForTimeout(2000);

                console.log('âœ… Thumbnail uploaded');
              } catch (err) {
                console.log('âš ï¸  Thumbnail upload failed:', err.message);
              }
            }

            // ã‚¿ã‚¤ãƒˆãƒ«è¨­å®š
            await page.fill('textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]', title);
            console.log('âœ… Title set');

            // æœ¬æ–‡è¨­å®šï¼ˆç”»åƒå‡¦ç†å«ã‚€ï¼‰
            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible' });
            await bodyBox.click();

            const lines = body.split('\n');
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // ç”»åƒè¡Œã®å ´åˆã¯ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
              const imageMatch = line.match(/!\[([^\]]*)\]\(([^)]+)\)/);
              if (imageMatch) {
                const imagePath = imageMatch[2];
                const image = images.find(img => img.localPath === imagePath);
                
                if (image && fs.existsSync(image.absolutePath)) {
                  console.log(`  Uploading image: ${image.localPath}`);
                  
                  // ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãƒšãƒ¼ã‚¹ãƒˆ
                  const imageBuffer = fs.readFileSync(image.absolutePath);
                  const base64Image = imageBuffer.toString('base64');
                  const mimeType = image.absolutePath.endsWith('.png') ? 'image/png' : 
                                   image.absolutePath.endsWith('.jpg') || image.absolutePath.endsWith('.jpeg') ? 'image/jpeg' : 
                                   'image/gif';
                  
                  await page.evaluate(async ({ base64, mime }) => {
                    const blob = await fetch(`data:${mime};base64,${base64}`).then(r => r.blob());
                    await navigator.clipboard.write([
                      new ClipboardItem({ [mime]: blob })
                    ]);
                  }, { base64: base64Image, mime: mimeType });
                  
                  // ãƒšãƒ¼ã‚¹ãƒˆ
                  await page.keyboard.press('Control+V');
                  await page.waitForTimeout(1000);
                  
                  console.log(`  âœ… Image uploaded: ${image.localPath}`);
                } else {
                  // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦å…¥åŠ›
                  await page.keyboard.type(line);
                }
              } else {
                // é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆè¡Œ
                await page.keyboard.type(line);
              }
              
              if (i < lines.length - 1) {
                await page.keyboard.press('Enter');
                await page.waitForTimeout(50);
              }
            }
            console.log('âœ… Body set');

            if (!isPublic) {
              // ä¸‹æ›¸ãä¿å­˜
              const saveBtn = page.locator('button:has-text("ä¸‹æ›¸ãä¿å­˜")').first();
              await saveBtn.waitFor({ state: 'visible' });
              await saveBtn.click();
              await page.waitForTimeout(3000);
              console.log('âœ… Draft saved');
            } else {
              // å…¬é–‹å‡¦ç†
              const proceedBtn = page.locator('button:has-text("å…¬é–‹ã«é€²ã‚€")').first();
              await proceedBtn.waitFor({ state: 'visible' });
              await proceedBtn.click();
              await page.waitForTimeout(2000);

              // ã‚¿ã‚°è¿½åŠ 
              if (tags.length > 0) {
                const tagInput = page.locator('input[placeholder*="ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°"]').first();
                await tagInput.waitFor({ state: 'visible' });
                for (const tag of tags) {
                  await tagInput.fill(tag);
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(200);
                }
                console.log('âœ… Tags added');
              }

              // æŠ•ç¨¿
              const publishBtn = page.locator('button:has-text("æŠ•ç¨¿ã™ã‚‹")').first();
              await publishBtn.waitFor({ state: 'visible' });
              await publishBtn.click();
              await page.waitForTimeout(5000);
              console.log('âœ… Published');
            }

            const finalUrl = page.url();
            console.log('ğŸ‰ Success!');
            console.log('   URL:', finalUrl);

            await browser.close();
          }

          main().catch(err => {
            console.error('âŒ Error:', err);
            process.exit(1);
          });
          EOFSCRIPT

          echo "âœ… Posting script created"

      - name: Execute post to note.com
        run: |
          export MD_FILE="${{ env.MD_FILE }}"
          export THUMBNAIL_PATH="${{ env.THUMBNAIL_PATH }}"
          export POST_TYPE="${{ github.event.inputs.post_type }}"
          
          node ./post-script.mjs

      - name: Upload error screenshot
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: error-screenshot
          path: error-screenshot.png
          if-no-files-found: ignore
          retention-days: 7

      - name: Summary
        if: always()
        run: |
          echo "## ğŸ“ Note Post Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Target Folder | \`${{ github.event.inputs.target_folder }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Post Type | **${{ github.event.inputs.post_type }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Markdown File | \`${{ env.MD_FILE }}\` |" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ env.THUMBNAIL_PATH }}" ]; then
            echo "| Thumbnail | \`${{ env.THUMBNAIL_PATH }}\` |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Thumbnail | None |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Completed at: \`$(date)\`" >> $GITHUB_STEP_SUMMARY
