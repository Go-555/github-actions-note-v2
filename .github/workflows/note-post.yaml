name: Note Post via MCP

on:
  workflow_dispatch:
    inputs:
      target_folder:
        description: 'æŠ•ç¨¿ã™ã‚‹noteé…ä¸‹ã®ãƒ•ã‚©ãƒ«ãƒ€å (ä¾‹: exsample)'
        required: true
        type: string
      post_type:
        description: 'æŠ•ç¨¿ã‚¿ã‚¤ãƒ—'
        required: true
        type: choice
        options:
          - draft
          - publish
        default: draft
      thumbnail_name:
        description: 'ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç”»åƒã€ä¾‹: sample-thumbnail.pngï¼‰'
        required: false
        type: string

jobs:
  post-to-note:
    runs-on: ubuntu-latest
    container: mcr.microsoft.com/playwright:v1.56.1-jammy
    timeout-minutes: 15
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate target folder
        run: |
          TARGET_PATH="note/${{ github.event.inputs.target_folder }}"
          if [ ! -d "$TARGET_PATH" ]; then
            echo "âŒ Error: Folder $TARGET_PATH does not exist"
            exit 1
          fi
          
          # mdãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
          MD_FILE=$(find "$TARGET_PATH" -maxdepth 1 -name "*.md" -type f | head -n 1)
          if [ -z "$MD_FILE" ]; then
            echo "âŒ Error: No markdown file found in $TARGET_PATH"
            exit 1
          fi
          
          echo "âœ… Found markdown file: $MD_FILE"
          echo "MD_FILE=$MD_FILE" >> $GITHUB_ENV
          echo "TARGET_PATH=$TARGET_PATH" >> $GITHUB_ENV

      - name: Setup authentication state
        run: |
          echo '${{ secrets.NOTE_STATE_JSON }}' > ~/.note-state.json
          if [ ! -s ~/.note-state.json ]; then
            echo "âŒ Error: NOTE_STATE_JSON secret is empty"
            echo "Please set NOTE_STATE_JSON secret in repository settings"
            echo "Run 'npm run login' locally to generate the state file"
            exit 1
          fi
          echo "âœ… Authentication state file created"

      - name: Determine thumbnail path
        run: |
          if [ -n "${{ github.event.inputs.thumbnail_name }}" ]; then
            THUMBNAIL_PATH="${{ env.TARGET_PATH }}/${{ github.event.inputs.thumbnail_name }}"
            if [ -f "$THUMBNAIL_PATH" ]; then
              echo "THUMBNAIL_PATH=$THUMBNAIL_PATH" >> $GITHUB_ENV
              echo "âœ… Using thumbnail: $THUMBNAIL_PATH"
            else
              echo "âš ï¸  Warning: Specified thumbnail not found: $THUMBNAIL_PATH"
            fi
          fi

      - name: Install minimal deps
        run: |
          npm i playwright@1.56.1
          echo "âœ… Playwright runtime ready (using preinstalled browsers in container)"

      - name: Create posting script
        run: |
          cat > ./post-script.mjs << 'EOFSCRIPT'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import path from 'path';

          // parseMarkdowné–¢æ•°
          function parseMarkdown(content) {
            const lines = content.split('\n');
            let title = '';
            let body = '';
            const tags = [];
            let inFrontMatter = false;
            let frontMatterEnded = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              if (line.trim() === '---') {
                if (!frontMatterEnded) {
                  inFrontMatter = !inFrontMatter;
                  if (!inFrontMatter) {
                    frontMatterEnded = true;
                  }
                  continue;
                }
              }

              if (inFrontMatter) {
                if (line.startsWith('title:')) {
                  title = line.substring(6).trim().replace(/^["']|["']$/g, '');
                } else if (line.startsWith('tags:')) {
                  const tagsStr = line.substring(5).trim();
                  if (tagsStr.startsWith('[') && tagsStr.endsWith(']')) {
                    tags.push(...tagsStr.slice(1, -1).split(',').map(t => t.trim().replace(/^["']|["']$/g, '')));
                  }
                } else if (line.trim().startsWith('-')) {
                  const tag = line.trim().substring(1).trim().replace(/^["']|["']$/g, '');
                  if (tag) tags.push(tag);
                }
                continue;
              }

              if (!title && line.startsWith('# ')) {
                title = line.substring(2).trim();
                continue;
              }

              if (frontMatterEnded || !line.trim().startsWith('---')) {
                body += line + '\n';
              }
            }

            return {
              title: title || 'Untitled',
              body: body.trim(),
              tags: tags.filter(Boolean),
            };
          }

          // ç”»åƒæŠ½å‡ºé–¢æ•°
          function extractImages(markdown, baseDir) {
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            const images = [];
            let match;

            while ((match = imageRegex.exec(markdown)) !== null) {
              const alt = match[1] || 'image';
              const imagePath = match[2];
              
              if (!imagePath.startsWith('http://') && !imagePath.startsWith('https://')) {
                const absolutePath = path.resolve(baseDir, imagePath);
                if (fs.existsSync(absolutePath)) {
                  images.push({
                    alt,
                    localPath: imagePath,
                    absolutePath,
                    placeholder: match[0],
                  });
                }
              }
            }

            return images;
          }

          // ãƒ¡ã‚¤ãƒ³å‡¦ç†
          async function main() {
            const markdownPath = process.env.MD_FILE;
            const thumbnailPath = process.env.THUMBNAIL_PATH || '';
            const isPublic = process.env.POST_TYPE === 'publish';
            const statePath = path.join(process.env.HOME, '.note-state.json');

            console.log('ğŸ“ Starting note.com post...');
            console.log('  Markdown:', markdownPath);
            console.log('  Thumbnail:', thumbnailPath || 'None');
            console.log('  Type:', isPublic ? 'Publish' : 'Draft');

            const mdContent = fs.readFileSync(markdownPath, 'utf-8');
            const { title, body, tags } = parseMarkdown(mdContent);
            const baseDir = path.dirname(markdownPath);
            const images = extractImages(body, baseDir);

            console.log('  Title:', title);
            console.log('  Tags:', tags.join(', '));
            console.log('  Images:', images.length);

            const browser = await chromium.launch({
              headless: true,
              args: [
                '--lang=ja-JP',
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-blink-features=AutomationControlled',
              ],
            });

            const context = await browser.newContext({
              storageState: statePath,
              locale: 'ja-JP',
              permissions: ['clipboard-read', 'clipboard-write'],
              userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
              viewport: { width: 1280, height: 720 },
              deviceScaleFactor: 1,
              isMobile: false,
              hasTouch: false,
            });

            const page = await context.newPage();
            page.setDefaultTimeout(180000);
            
            // Headlessæ¤œçŸ¥ã‚’å›é¿
            await page.addInitScript(() => {
              Object.defineProperty(navigator, 'webdriver', {
                get: () => false,
              });
              // Chromeç‰¹æœ‰ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
              window.chrome = {
                runtime: {},
              };
              // Permissions APIã®ãƒ¢ãƒƒã‚¯
              const originalQuery = window.navigator.permissions.query;
              window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                  Promise.resolve({ state: Notification.permission }) :
                  originalQuery(parameters)
              );
            });

            await context.grantPermissions(['clipboard-read', 'clipboard-write'], { 
              origin: 'https://editor.note.com' 
            });

            // ã¾ãšãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèª
            console.log('ğŸ” Checking authentication status...');
            await page.goto('https://note.com', { waitUntil: 'networkidle' });
            await page.waitForTimeout(2000);
            
            // ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã®ç¢ºèªï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼‰
            const loginCheck = await page.evaluate(() => {
              return {
                hasNotificationIcon: !!document.querySelector('[aria-label*="é€šçŸ¥"]'),
                hasNoteCreateButton: Array.from(document.querySelectorAll('a')).some(a => a.textContent.includes('è¨˜äº‹ã‚’æ›¸ã')),
                hasLoginLink: !!document.querySelector('a[href*="/login"]'),
              };
            });
            
            // é€šçŸ¥ã‚¢ã‚¤ã‚³ãƒ³ãŒã‚ã‚‹ã‹ã€è¨˜äº‹ã‚’æ›¸ããƒœã‚¿ãƒ³ãŒã‚ã‚Œã°ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿
            const isLoggedIn = loginCheck.hasNotificationIcon || loginCheck.hasNoteCreateButton || !loginCheck.hasLoginLink;
            
            console.log(`ğŸ” Login status: ${isLoggedIn ? 'Logged in' : 'Not logged in'}`);
            
            if (!isLoggedIn) {
              throw new Error('Authentication failed. Please check NOTE_STATE_JSON.');
            }
            
            try {
              console.log('ğŸŒ Navigating to editor...');
              await page.goto('https://editor.note.com/new', { 
                waitUntil: 'networkidle',
                timeout: 180000 
              });
              
              console.log('â³ Waiting for editor to load...');
              
              // ã‚¨ãƒ‡ã‚£ã‚¿ã®åŸºæœ¬è¦ç´ ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
              await page.waitForLoadState('networkidle');
              await page.waitForSelector('textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]', { timeout: 30000 });
              console.log('âœ… Editor loaded successfully');
            } catch (error) {
              console.error('âŒ Failed to load editor page');
              console.error('Error:', error.message);
              
              // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ’®å½±
              const screenshotPath = 'error-screenshot.png';
              await page.screenshot({ path: screenshotPath, fullPage: true });
              console.log(`ğŸ“¸ Screenshot saved: ${screenshotPath}`);
              
              // ç¾åœ¨ã®URLã‚’è¡¨ç¤º
              console.log('Current URL:', page.url());
              
              // ãƒšãƒ¼ã‚¸ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¡¨ç¤º
              const pageTitle = await page.title();
              console.log('Page Title:', pageTitle);
              
              await browser.close();
              throw error;
            }

            // ã‚µãƒ ãƒã‚¤ãƒ«å‡¦ç†ï¼ˆå‚è€ƒã‚³ãƒ¼ãƒ‰ã®å …ç‰¢ãªæ–¹æ³•ã‚’æ¡ç”¨ï¼‰
            if (thumbnailPath && fs.existsSync(thumbnailPath)) {
              console.log('ğŸ–¼ï¸  Uploading thumbnail...');
              try {
                // è¤‡æ•°ã®ã€Œç”»åƒã‚’è¿½åŠ ã€ãƒœã‚¿ãƒ³ãŒã‚ã‚‹å ´åˆã€æœ€ã‚‚ä¸Šã®ã‚‚ã®ï¼ˆYåº§æ¨™ãŒå°ã•ã„ï¼‰ã‚’é¸æŠ
                const candidates = page.locator('button[aria-label="ç”»åƒã‚’è¿½åŠ "]');
                await candidates.first().waitFor({ state: 'visible', timeout: 15000 });

                let target = candidates.first();
                const cnt = await candidates.count();
                if (cnt > 1) {
                  console.log(`ğŸ” Found ${cnt} "ç”»åƒã‚’è¿½åŠ " buttons, selecting the topmost one`);
                  let minY = Infinity;
                  let idx = 0;
                  for (let i = 0; i < cnt; i++) {
                    const box = await candidates.nth(i).boundingBox();
                    if (box && box.y < minY) {
                      minY = box.y;
                      idx = i;
                    }
                  }
                  target = candidates.nth(idx);
                  console.log(`âœ… Selected button at index ${idx} (Y: ${minY})`);
                }

                await target.scrollIntoViewIfNeeded();
                await target.click({ force: true });

                const uploadBtn = page.locator('button:has-text("ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰")').first();
                await uploadBtn.waitFor({ state: 'visible', timeout: 10000 });

                // filechooserã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰
                let chooser = null;
                try {
                  [chooser] = await Promise.all([
                    page.waitForEvent('filechooser', { timeout: 5000 }),
                    uploadBtn.click({ force: true }),
                  ]);
                } catch (e) {
                  console.log('â„¹ï¸  filechooser event not captured, using fallback');
                }

                if (chooser) {
                  await chooser.setFiles(thumbnailPath);
                } else {
                  await uploadBtn.click({ force: true }).catch(() => {});
                  const fileInput = page.locator('input[type="file"]').first();
                  await fileInput.waitFor({ state: 'attached', timeout: 10000 });
                  await fileInput.setInputFiles(thumbnailPath);
                }

                // ãƒˆãƒªãƒŸãƒ³ã‚°ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®å‡¦ç†
                const dialog = page.locator('div[role="dialog"]');
                await dialog.waitFor({ state: 'visible', timeout: 10000 });

                const saveThumbBtn = dialog.locator('button:has-text("ä¿å­˜")').first();
                const cropper = dialog.locator('[data-testid="cropper"]').first();

                // cropperã¨saveãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’ç¢ºèª
                const cropperEl = await cropper.elementHandle();
                const saveEl = await saveThumbBtn.elementHandle();

                if (cropperEl && saveEl) {
                  await Promise.race([
                    page.waitForFunction(
                      (el) => getComputedStyle(el).pointerEvents === 'none',
                      cropperEl,
                      { timeout: 10000 }
                    ),
                    page.waitForFunction(
                      (el) => !el.disabled,
                      saveEl,
                      { timeout: 10000 }
                    ),
                  ]).catch(() => {});
                }

                await saveThumbBtn.click();
                await dialog.waitFor({ state: 'hidden', timeout: 10000 }).catch(() => {});
                await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});

                // åæ˜ ç¢ºèª
                const changedBtn = page.locator('button[aria-label="ç”»åƒã‚’å¤‰æ›´"]');
                const addBtn = page.locator('button[aria-label="ç”»åƒã‚’è¿½åŠ "]');

                let applied = false;
                try {
                  await changedBtn.waitFor({ state: 'visible', timeout: 5000 });
                  applied = true;
                } catch {}
                if (!applied) {
                  try {
                    await addBtn.waitFor({ state: 'hidden', timeout: 5000 });
                    applied = true;
                  } catch {}
                }

                console.log(applied ? 'âœ… Thumbnail uploaded and verified' : 'âš ï¸  Thumbnail uploaded but verification uncertain');
              } catch (err) {
                console.log('âš ï¸  Thumbnail upload failed:', err.message);
              }
            }

            // ã‚¿ã‚¤ãƒˆãƒ«è¨­å®š
            console.log('ğŸ“ Setting title...');
            console.log(`   Target title: "${title}"`);
            await page.waitForTimeout(500);
            
            const titleField = page.locator('textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]').first();
            
            // ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›å‰ã®å€¤ã‚’ç¢ºèª
            const beforeValue = await titleField.inputValue();
            console.log(`   Before fill: "${beforeValue}"`);
            
            // æ–¹æ³•1: fillã‚’è©¦ã™
            await titleField.fill(title);
            await page.waitForTimeout(300);
            
            // å…¥åŠ›å¾Œã®å€¤ã‚’ç¢ºèª
            const afterFillValue = await titleField.inputValue();
            console.log(`   After fill: "${afterFillValue}"`);
            
            // fillãŒå¤±æ•—ã—ã¦ã„ã‚‹å ´åˆã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if (afterFillValue !== title) {
              console.log('   â„¹ï¸  fill() did not work, trying keyboard input...');
              await titleField.click();
              await titleField.clear();
              await page.keyboard.type(title);
              await page.waitForTimeout(300);
              
              const afterTypeValue = await titleField.inputValue();
              console.log(`   After keyboard type: "${afterTypeValue}"`);
            }
            
            console.log('âœ… Title set');

            // æœ¬æ–‡è¨­å®š
            console.log('ğŸ“ Setting body...');
            await page.waitForTimeout(500);
            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible', timeout: 10000 });
            
            // Adobe Expressã®ãƒ˜ãƒ«ãƒ—ãŒé‚ªé­”ã™ã‚‹å ´åˆã«å‚™ãˆã¦ã€Escapeã‚­ãƒ¼ã§å…¨ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            await page.keyboard.press('Escape');
            await page.waitForTimeout(300);
            
            // è¦ç´ ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å½“ã¦ã‚‹ï¼ˆã‚¯ãƒªãƒƒã‚¯ã®ä»£ã‚ã‚Šã«ç›´æ¥ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼‰
            await bodyBox.evaluate(el => {
              el.focus();
              // ã‚«ãƒ¼ã‚½ãƒ«ã‚’æœ«å°¾ã«ç§»å‹•
              const range = document.createRange();
              const sel = window.getSelection();
              range.selectNodeContents(el);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
            });

            // ç”»åƒã‚’å«ã¾ãªã„å ´åˆã¯ã€Markdownå…¨ä½“ã‚’ä¸€æ‹¬ã§ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰çµŒç”±ã§ãƒšãƒ¼ã‚¹ãƒˆ
            if (images.length === 0) {
              console.log('ğŸ“‹ Pasting entire content via clipboard...');
              console.log(`   Content length: ${body.length} characters`);
              
              // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«æ›¸ãè¾¼ã‚€
              await page.evaluate(async (text) => {
                await navigator.clipboard.writeText(text);
              }, body);
              
              // æœ¬æ–‡ã‚¨ãƒªã‚¢ãŒãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
              const isFocused = await bodyBox.evaluate(el => {
                return document.activeElement === el;
              });
              console.log(`   Body box focused: ${isFocused}`);
              
              // ãƒšãƒ¼ã‚¹ãƒˆ
              await page.keyboard.press('Control+V');
              await page.waitForTimeout(1000);
              
              // ãƒšãƒ¼ã‚¹ãƒˆå¾Œã®å†…å®¹ã‚’ç¢ºèª
              const afterContent = await bodyBox.textContent();
              console.log(`   After paste length: ${afterContent.length} characters`);
              console.log('âœ… Content pasted');
            } else {
              // ç”»åƒãŒã‚ã‚‹å ´åˆã¯ã€ç”»åƒãƒãƒ¼ã‚«ãƒ¼ã§åˆ†å‰²ã—ã¦å‡¦ç†
              console.log(`ğŸ“‹ Processing content with ${images.length} images...`);
              
              // ç”»åƒã®ä½ç½®ã§æœ¬æ–‡ã‚’åˆ†å‰²
              const parts = [];
              let lastIndex = 0;
              const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
              let match;
              
              while ((match = imageRegex.exec(body)) !== null) {
                // ç”»åƒã®å‰ã®ãƒ†ã‚­ã‚¹ãƒˆ
                if (match.index > lastIndex) {
                  parts.push({ type: 'text', content: body.slice(lastIndex, match.index) });
                }
                // ç”»åƒ
                const imagePath = match[2];
                const image = images.find(img => img.localPath === imagePath);
                if (image) {
                  parts.push({ type: 'image', image: image });
                }
                lastIndex = match.index + match[0].length;
              }
              
              // æœ€å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆ
              if (lastIndex < body.length) {
                parts.push({ type: 'text', content: body.slice(lastIndex) });
              }
              
              // å„ãƒ‘ãƒ¼ãƒˆã‚’é †ç•ªã«æŒ¿å…¥
              for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                console.log(`   Processing part ${i+1}/${parts.length}: type=${part.type}`);
                
                if (part.type === 'text' && part.content.trim()) {
                  console.log(`   Text part length: ${part.content.length} characters`);
                  
                  // ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡Œã”ã¨ã«åˆ†å‰²ã—ã€URLè¡Œã¨ãã‚Œä»¥å¤–ã‚’åŒºåˆ¥ã—ã¦å‡¦ç†
                  const lines = part.content.split('\n');
                  let buffer = '';
                  let urlCount = 0;
                  
                  for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                    const line = lines[lineIdx];
                    const isUrlLine = /^https?:\/\/[^\s]+$/.test(line.trim());
                    
                    if (isUrlLine) {
                      // ãƒãƒƒãƒ•ã‚¡ã«ã‚ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…ˆã«è²¼ã‚Šä»˜ã‘ï¼ˆç©ºè¡Œã‚‚ä¿æŒï¼‰
                      if (buffer) {
                        await page.evaluate(async (text) => {
                          await navigator.clipboard.writeText(text);
                        }, buffer);
                        await page.keyboard.press('Control+V');
                        await page.waitForTimeout(100);
                        buffer = '';
                      }
                      
                      // URLè¡Œã‚’è²¼ã‚Šä»˜ã‘
                      await page.evaluate(async (text) => {
                        await navigator.clipboard.writeText(text);
                      }, line);
                      await page.keyboard.press('Control+V');
                      await page.waitForTimeout(100);
                      
                      // Enterã§ãƒªãƒ³ã‚¯ã‚«ãƒ¼ãƒ‰åŒ–
                      await page.keyboard.press('Enter');
                      await page.waitForTimeout(1200); // ãƒªãƒ³ã‚¯ã‚«ãƒ¼ãƒ‰å±•é–‹ã‚’ã—ã£ã‹ã‚Šå¾…ã¤
                      urlCount++;
                      
                    } else {
                      // é€šå¸¸è¡Œã¯ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ ï¼ˆæ”¹è¡Œã‚‚ä¿æŒï¼‰
                      buffer += line + (lineIdx < lines.length - 1 ? '\n' : '');
                    }
                  }
                  
                  // æ®‹ã‚Šã®ãƒãƒƒãƒ•ã‚¡ã‚’è²¼ã‚Šä»˜ã‘ï¼ˆç©ºã§ãªã‘ã‚Œã°ï¼‰
                  if (buffer) {
                    await page.evaluate(async (text) => {
                      await navigator.clipboard.writeText(text);
                    }, buffer);
                    await page.keyboard.press('Control+V');
                    await page.waitForTimeout(100);
                  }
                  
                  if (urlCount > 0) {
                    console.log(`   â„¹ï¸  Processed ${urlCount} URL line(s) with Enter for link cards`);
                  }
                  console.log(`   âœ… Text pasted`);
                } else if (part.type === 'image' && fs.existsSync(part.image.absolutePath)) {
                  console.log(`  ğŸ“¸ Uploading image: ${part.image.localPath}`);
                  
                  // ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãƒšãƒ¼ã‚¹ãƒˆ
                  const imageBuffer = fs.readFileSync(part.image.absolutePath);
                  const base64Image = imageBuffer.toString('base64');
                  const mimeType = part.image.absolutePath.endsWith('.png') ? 'image/png' : 
                                   part.image.absolutePath.endsWith('.jpg') || part.image.absolutePath.endsWith('.jpeg') ? 'image/jpeg' : 
                                   'image/gif';
                  
                  await page.evaluate(async ({ base64, mime }) => {
                    const blob = await fetch(`data:${mime};base64,${base64}`).then(r => r.blob());
                    await navigator.clipboard.write([
                      new ClipboardItem({ [mime]: blob })
                    ]);
                  }, { base64: base64Image, mime: mimeType });
                  
                  await page.keyboard.press('Control+V');
                  await page.waitForTimeout(1000);
                  
                  // ç”»åƒè²¼ã‚Šä»˜ã‘å¾Œã€æ”¹è¡Œã—ã¦ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(300);
                  
                  console.log(`  âœ… Image uploaded: ${part.image.localPath}`);
                }
              }
              console.log('âœ… Content with images inserted');
            }
            
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒåæ˜ ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
            console.log('â³ Waiting for content to be reflected...');
            await page.waitForTimeout(2000);
            
            // å…¥åŠ›å†…å®¹ã®æœ€çµ‚ç¢ºèª
            const finalTitleValue = await page.locator('textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]').first().inputValue();
            const finalBodyContent = await page.locator('div[contenteditable="true"][role="textbox"]').first().textContent();
            console.log(`ğŸ“Š Final check - Title: ${finalTitleValue.length} chars, Body: ${finalBodyContent.length} chars`);

            if (!isPublic) {
              // ä¸‹æ›¸ãä¿å­˜
              console.log('ğŸ’¾ Saving draft...');
              const saveBtn = page.locator('button:has-text("ä¸‹æ›¸ãä¿å­˜")').first();
              await saveBtn.waitFor({ state: 'visible' });
              
              // ä¿å­˜å‰ã«ã‚‚ã†ä¸€åº¦å¾…æ©Ÿ
              await page.waitForTimeout(1000);
              
              await saveBtn.click();
              
              // ä¿å­˜å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¾…ã¤
              await page.locator('text=ä¿å­˜ã—ã¾ã—ãŸ').waitFor({ timeout: 10000 }).catch(() => {
                console.log('â„¹ï¸  "ä¿å­˜ã—ã¾ã—ãŸ" message not found, but continuing...');
              });
              await page.waitForTimeout(2000);
              
              console.log('âœ… Draft saved');
            } else {
              // å…¬é–‹å‡¦ç†
              const proceedBtn = page.locator('button:has-text("å…¬é–‹ã«é€²ã‚€")').first();
              await proceedBtn.waitFor({ state: 'visible' });
              await proceedBtn.click();
              await page.waitForTimeout(2000);

              // ã‚¿ã‚°è¿½åŠ 
              if (tags.length > 0) {
                const tagInput = page.locator('input[placeholder*="ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°"]').first();
                await tagInput.waitFor({ state: 'visible' });
                for (const tag of tags) {
                  await tagInput.fill(tag);
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(200);
                }
                console.log('âœ… Tags added');
              }

              // æŠ•ç¨¿
              const publishBtn = page.locator('button:has-text("æŠ•ç¨¿ã™ã‚‹")').first();
              await publishBtn.waitFor({ state: 'visible' });
              await publishBtn.click();
              await page.waitForTimeout(5000);
              console.log('âœ… Published');
            }

            const finalUrl = page.url();
            console.log('ğŸ‰ Success!');
            console.log('   URL:', finalUrl);

            await browser.close();
          }

          main().catch(err => {
            console.error('âŒ Error:', err);
            process.exit(1);
          });
          EOFSCRIPT

          echo "âœ… Posting script created"

      - name: Execute post to note.com
        run: |
          export MD_FILE="${{ env.MD_FILE }}"
          export THUMBNAIL_PATH="${{ env.THUMBNAIL_PATH }}"
          export POST_TYPE="${{ github.event.inputs.post_type }}"
          
          node ./post-script.mjs

      - name: Upload error screenshot
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: error-screenshot
          path: error-screenshot.png
          if-no-files-found: ignore
          retention-days: 7

      - name: Summary
        if: always()
        run: |
          echo "## ğŸ“ Note Post Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Target Folder | \`${{ github.event.inputs.target_folder }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Post Type | **${{ github.event.inputs.post_type }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Markdown File | \`${{ env.MD_FILE }}\` |" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ env.THUMBNAIL_PATH }}" ]; then
            echo "| Thumbnail | \`${{ env.THUMBNAIL_PATH }}\` |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Thumbnail | None |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Completed at: \`$(date)\`" >> $GITHUB_STEP_SUMMARY
