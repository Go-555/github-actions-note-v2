name: Note Post via MCP

on:
  workflow_dispatch:
    inputs:
      target_folder:
        description: '投稿するnote配下のフォルダ名 (例: exsample)'
        required: true
        type: string
      post_type:
        description: '投稿タイプ'
        required: true
        type: choice
        options:
          - draft
          - publish
        default: draft
      thumbnail_name:
        description: 'サムネイル画像ファイル名（フォルダ内の画像、例: sample-thumbnail.png）'
        required: false
        type: string

jobs:
  post-to-note:
    runs-on: ubuntu-latest
    container: mcr.microsoft.com/playwright:v1.56.1-jammy
    timeout-minutes: 15
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate target folder
        run: |
          TARGET_PATH="note/${{ github.event.inputs.target_folder }}"
          if [ ! -d "$TARGET_PATH" ]; then
            echo "❌ Error: Folder $TARGET_PATH does not exist"
            exit 1
          fi
          
          # mdファイルを探す
          MD_FILE=$(find "$TARGET_PATH" -maxdepth 1 -name "*.md" -type f | head -n 1)
          if [ -z "$MD_FILE" ]; then
            echo "❌ Error: No markdown file found in $TARGET_PATH"
            exit 1
          fi
          
          echo "✅ Found markdown file: $MD_FILE"
          echo "MD_FILE=$MD_FILE" >> $GITHUB_ENV
          echo "TARGET_PATH=$TARGET_PATH" >> $GITHUB_ENV

      - name: Setup authentication state
        run: |
          echo '${{ secrets.NOTE_STATE_JSON }}' > ~/.note-state.json
          if [ ! -s ~/.note-state.json ]; then
            echo "❌ Error: NOTE_STATE_JSON secret is empty"
            echo "Please set NOTE_STATE_JSON secret in repository settings"
            echo "Run 'npm run login' locally to generate the state file"
            exit 1
          fi
          echo "✅ Authentication state file created"

      - name: Determine thumbnail path
        run: |
          if [ -n "${{ github.event.inputs.thumbnail_name }}" ]; then
            THUMBNAIL_PATH="${{ env.TARGET_PATH }}/${{ github.event.inputs.thumbnail_name }}"
            if [ -f "$THUMBNAIL_PATH" ]; then
              echo "THUMBNAIL_PATH=$THUMBNAIL_PATH" >> $GITHUB_ENV
              echo "✅ Using thumbnail: $THUMBNAIL_PATH"
            else
              echo "⚠️  Warning: Specified thumbnail not found: $THUMBNAIL_PATH"
            fi
          fi

      - name: Install minimal deps
        run: |
          npm i playwright@1.56.1
          echo "✅ Playwright runtime ready (using preinstalled browsers in container)"

      - name: Create posting script
        run: |
          cat > ./post-script.mjs << 'EOFSCRIPT'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import path from 'path';

          // parseMarkdown関数
          function parseMarkdown(content) {
            const lines = content.split('\n');
            let title = '';
            let body = '';
            const tags = [];
            let inFrontMatter = false;
            let frontMatterEnded = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              if (line.trim() === '---') {
                if (!frontMatterEnded) {
                  inFrontMatter = !inFrontMatter;
                  if (!inFrontMatter) {
                    frontMatterEnded = true;
                  }
                  continue;
                }
              }

              if (inFrontMatter) {
                if (line.startsWith('title:')) {
                  title = line.substring(6).trim().replace(/^["']|["']$/g, '');
                } else if (line.startsWith('tags:')) {
                  const tagsStr = line.substring(5).trim();
                  if (tagsStr.startsWith('[') && tagsStr.endsWith(']')) {
                    tags.push(...tagsStr.slice(1, -1).split(',').map(t => t.trim().replace(/^["']|["']$/g, '')));
                  }
                } else if (line.trim().startsWith('-')) {
                  const tag = line.trim().substring(1).trim().replace(/^["']|["']$/g, '');
                  if (tag) tags.push(tag);
                }
                continue;
              }

              if (!title && line.startsWith('# ')) {
                title = line.substring(2).trim();
                continue;
              }

              if (frontMatterEnded || !line.trim().startsWith('---')) {
                body += line + '\n';
              }
            }

            return {
              title: title || 'Untitled',
              body: body.trim(),
              tags: tags.filter(Boolean),
            };
          }

          // 画像抽出関数
          function extractImages(markdown, baseDir) {
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            const images = [];
            let match;

            while ((match = imageRegex.exec(markdown)) !== null) {
              const alt = match[1] || 'image';
              const imagePath = match[2];
              
              if (!imagePath.startsWith('http://') && !imagePath.startsWith('https://')) {
                const absolutePath = path.resolve(baseDir, imagePath);
                if (fs.existsSync(absolutePath)) {
                  images.push({
                    alt,
                    localPath: imagePath,
                    absolutePath,
                    placeholder: match[0],
                  });
                }
              }
            }

            return images;
          }

          // メイン処理
          async function main() {
            const markdownPath = process.env.MD_FILE;
            const thumbnailPath = process.env.THUMBNAIL_PATH || '';
            const isPublic = process.env.POST_TYPE === 'publish';
            const statePath = path.join(process.env.HOME, '.note-state.json');

            console.log('📝 Starting note.com post...');
            console.log('  Markdown:', markdownPath);
            console.log('  Thumbnail:', thumbnailPath || 'None');
            console.log('  Type:', isPublic ? 'Publish' : 'Draft');

            const mdContent = fs.readFileSync(markdownPath, 'utf-8');
            const { title, body, tags } = parseMarkdown(mdContent);
            const baseDir = path.dirname(markdownPath);
            const images = extractImages(body, baseDir);

            console.log('  Title:', title);
            console.log('  Tags:', tags.join(', '));
            console.log('  Images:', images.length);

            const browser = await chromium.launch({
              headless: true,
              args: [
                '--lang=ja-JP',
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-blink-features=AutomationControlled',
              ],
            });

            const context = await browser.newContext({
              storageState: statePath,
              locale: 'ja-JP',
              permissions: ['clipboard-read', 'clipboard-write'],
              userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
              viewport: { width: 1280, height: 720 },
              deviceScaleFactor: 1,
              isMobile: false,
              hasTouch: false,
            });

            const page = await context.newPage();
            page.setDefaultTimeout(180000);
            
            // Headless検知を回避
            await page.addInitScript(() => {
              Object.defineProperty(navigator, 'webdriver', {
                get: () => false,
              });
              // Chrome特有のプロパティを追加
              window.chrome = {
                runtime: {},
              };
              // Permissions APIのモック
              const originalQuery = window.navigator.permissions.query;
              window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                  Promise.resolve({ state: Notification.permission }) :
                  originalQuery(parameters)
              );
            });

            await context.grantPermissions(['clipboard-read', 'clipboard-write'], { 
              origin: 'https://editor.note.com' 
            });

            // まずホームページにアクセスして認証状態を確認
            console.log('🔐 Checking authentication status...');
            await page.goto('https://note.com', { waitUntil: 'networkidle' });
            await page.waitForTimeout(2000);
            
            // ログイン状態の確認（より確実な方法）
            const loginCheck = await page.evaluate(() => {
              return {
                hasNotificationIcon: !!document.querySelector('[aria-label*="通知"]'),
                hasNoteCreateButton: Array.from(document.querySelectorAll('a')).some(a => a.textContent.includes('記事を書く')),
                hasLoginLink: !!document.querySelector('a[href*="/login"]'),
              };
            });
            
            // 通知アイコンがあるか、記事を書くボタンがあればログイン済み
            const isLoggedIn = loginCheck.hasNotificationIcon || loginCheck.hasNoteCreateButton || !loginCheck.hasLoginLink;
            
            console.log(`🔐 Login status: ${isLoggedIn ? 'Logged in' : 'Not logged in'}`);
            
            if (!isLoggedIn) {
              throw new Error('Authentication failed. Please check NOTE_STATE_JSON.');
            }
            
            try {
              console.log('🌐 Navigating to editor...');
              await page.goto('https://editor.note.com/new', { 
                waitUntil: 'networkidle',
                timeout: 180000 
              });
              
              console.log('⏳ Waiting for editor to load...');
              
              // エディタの基本要素が読み込まれるまで待機
              await page.waitForLoadState('networkidle');
              await page.waitForSelector('textarea[placeholder*="タイトル"]', { timeout: 30000 });
              console.log('✅ Editor loaded successfully');
            } catch (error) {
              console.error('❌ Failed to load editor page');
              console.error('Error:', error.message);
              
              // スクリーンショットを撮影
              const screenshotPath = 'error-screenshot.png';
              await page.screenshot({ path: screenshotPath, fullPage: true });
              console.log(`📸 Screenshot saved: ${screenshotPath}`);
              
              // 現在のURLを表示
              console.log('Current URL:', page.url());
              
              // ページのタイトルを表示
              const pageTitle = await page.title();
              console.log('Page Title:', pageTitle);
              
              await browser.close();
              throw error;
            }

            // サムネイル処理（参考コードの堅牢な方法を採用）
            if (thumbnailPath && fs.existsSync(thumbnailPath)) {
              console.log('🖼️  Uploading thumbnail...');
              try {
                // 複数の「画像を追加」ボタンがある場合、最も上のもの（Y座標が小さい）を選択
                const candidates = page.locator('button[aria-label="画像を追加"]');
                await candidates.first().waitFor({ state: 'visible', timeout: 15000 });

                let target = candidates.first();
                const cnt = await candidates.count();
                if (cnt > 1) {
                  console.log(`🔍 Found ${cnt} "画像を追加" buttons, selecting the topmost one`);
                  let minY = Infinity;
                  let idx = 0;
                  for (let i = 0; i < cnt; i++) {
                    const box = await candidates.nth(i).boundingBox();
                    if (box && box.y < minY) {
                      minY = box.y;
                      idx = i;
                    }
                  }
                  target = candidates.nth(idx);
                  console.log(`✅ Selected button at index ${idx} (Y: ${minY})`);
                }

                await target.scrollIntoViewIfNeeded();
                await target.click({ force: true });

                const uploadBtn = page.locator('button:has-text("画像をアップロード")').first();
                await uploadBtn.waitFor({ state: 'visible', timeout: 10000 });

                // filechooserイベントを待つ（フォールバック付き）
                let chooser = null;
                try {
                  [chooser] = await Promise.all([
                    page.waitForEvent('filechooser', { timeout: 5000 }),
                    uploadBtn.click({ force: true }),
                  ]);
                } catch (e) {
                  console.log('ℹ️  filechooser event not captured, using fallback');
                }

                if (chooser) {
                  await chooser.setFiles(thumbnailPath);
                } else {
                  await uploadBtn.click({ force: true }).catch(() => {});
                  const fileInput = page.locator('input[type="file"]').first();
                  await fileInput.waitFor({ state: 'attached', timeout: 10000 });
                  await fileInput.setInputFiles(thumbnailPath);
                }

                // トリミングダイアログの処理
                const dialog = page.locator('div[role="dialog"]');
                await dialog.waitFor({ state: 'visible', timeout: 10000 });

                const saveThumbBtn = dialog.locator('button:has-text("保存")').first();
                const cropper = dialog.locator('[data-testid="cropper"]').first();

                // cropperとsaveボタンの状態を確認
                const cropperEl = await cropper.elementHandle();
                const saveEl = await saveThumbBtn.elementHandle();

                if (cropperEl && saveEl) {
                  await Promise.race([
                    page.waitForFunction(
                      (el) => getComputedStyle(el).pointerEvents === 'none',
                      cropperEl,
                      { timeout: 10000 }
                    ),
                    page.waitForFunction(
                      (el) => !el.disabled,
                      saveEl,
                      { timeout: 10000 }
                    ),
                  ]).catch(() => {});
                }

                await saveThumbBtn.click();
                await dialog.waitFor({ state: 'hidden', timeout: 10000 }).catch(() => {});
                await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});

                // 反映確認
                const changedBtn = page.locator('button[aria-label="画像を変更"]');
                const addBtn = page.locator('button[aria-label="画像を追加"]');

                let applied = false;
                try {
                  await changedBtn.waitFor({ state: 'visible', timeout: 5000 });
                  applied = true;
                } catch {}
                if (!applied) {
                  try {
                    await addBtn.waitFor({ state: 'hidden', timeout: 5000 });
                    applied = true;
                  } catch {}
                }

                console.log(applied ? '✅ Thumbnail uploaded and verified' : '⚠️  Thumbnail uploaded but verification uncertain');
              } catch (err) {
                console.log('⚠️  Thumbnail upload failed:', err.message);
              }
            }

            // タイトル設定
            console.log('📝 Setting title...');
            console.log(`   Target title: "${title}"`);
            await page.waitForTimeout(500);
            
            const titleField = page.locator('textarea[placeholder*="タイトル"]').first();
            
            // タイトル入力前の値を確認
            const beforeValue = await titleField.inputValue();
            console.log(`   Before fill: "${beforeValue}"`);
            
            // 方法1: fillを試す
            await titleField.fill(title);
            await page.waitForTimeout(300);
            
            // 入力後の値を確認
            const afterFillValue = await titleField.inputValue();
            console.log(`   After fill: "${afterFillValue}"`);
            
            // fillが失敗している場合、キーボード入力にフォールバック
            if (afterFillValue !== title) {
              console.log('   ℹ️  fill() did not work, trying keyboard input...');
              await titleField.click();
              await titleField.clear();
              await page.keyboard.type(title);
              await page.waitForTimeout(300);
              
              const afterTypeValue = await titleField.inputValue();
              console.log(`   After keyboard type: "${afterTypeValue}"`);
            }
            
            console.log('✅ Title set');

            // 本文設定
            console.log('📝 Setting body...');
            await page.waitForTimeout(500);
            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible', timeout: 10000 });
            
            // Adobe Expressのヘルプが邪魔する場合に備えて、Escapeキーで全てのモーダルを閉じる
            await page.keyboard.press('Escape');
            await page.waitForTimeout(300);
            
            // 要素にフォーカスを当てる（クリックの代わりに直接フォーカス）
            await bodyBox.evaluate(el => {
              el.focus();
              // カーソルを末尾に移動
              const range = document.createRange();
              const sel = window.getSelection();
              range.selectNodeContents(el);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
            });

            // 画像を含まない場合は、Markdown全体を一括でクリップボード経由でペースト
            if (images.length === 0) {
              console.log('📋 Pasting entire content via clipboard...');
              console.log(`   Content length: ${body.length} characters`);
              
              // クリップボードに書き込む
              await page.evaluate(async (text) => {
                await navigator.clipboard.writeText(text);
              }, body);
              
              // 本文エリアがフォーカスされているか確認
              const isFocused = await bodyBox.evaluate(el => {
                return document.activeElement === el;
              });
              console.log(`   Body box focused: ${isFocused}`);
              
              // ペースト
              await page.keyboard.press('Control+V');
              await page.waitForTimeout(1000);
              
              // ペースト後の内容を確認
              const afterContent = await bodyBox.textContent();
              console.log(`   After paste length: ${afterContent.length} characters`);
              console.log('✅ Content pasted');
            } else {
              // 画像がある場合は、画像マーカーで分割して処理
              console.log(`📋 Processing content with ${images.length} images...`);
              
              // 画像の位置で本文を分割
              const parts = [];
              let lastIndex = 0;
              const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
              let match;
              
              while ((match = imageRegex.exec(body)) !== null) {
                // 画像の前のテキスト
                if (match.index > lastIndex) {
                  parts.push({ type: 'text', content: body.slice(lastIndex, match.index) });
                }
                // 画像
                const imagePath = match[2];
                const image = images.find(img => img.localPath === imagePath);
                if (image) {
                  parts.push({ type: 'image', image: image });
                }
                lastIndex = match.index + match[0].length;
              }
              
              // 最後のテキスト
              if (lastIndex < body.length) {
                parts.push({ type: 'text', content: body.slice(lastIndex) });
              }
              
              // 各パートを順番に挿入
              for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                console.log(`   Processing part ${i+1}/${parts.length}: type=${part.type}`);
                
                if (part.type === 'text' && part.content.trim()) {
                  console.log(`   Text part length: ${part.content.length} characters`);
                  
                  // テキストを行ごとに分割し、URL行とそれ以外を区別して処理
                  const lines = part.content.split('\n');
                  let buffer = '';
                  let urlCount = 0;
                  
                  for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                    const line = lines[lineIdx];
                    const isUrlLine = /^https?:\/\/[^\s]+$/.test(line.trim());
                    
                    if (isUrlLine) {
                      // バッファにあるテキストを先に貼り付け（空行も保持）
                      if (buffer) {
                        await page.evaluate(async (text) => {
                          await navigator.clipboard.writeText(text);
                        }, buffer);
                        await page.keyboard.press('Control+V');
                        await page.waitForTimeout(100);
                        buffer = '';
                      }
                      
                      // URL行を貼り付け
                      await page.evaluate(async (text) => {
                        await navigator.clipboard.writeText(text);
                      }, line);
                      await page.keyboard.press('Control+V');
                      await page.waitForTimeout(100);
                      
                      // Enterでリンクカード化
                      await page.keyboard.press('Enter');
                      await page.waitForTimeout(1200); // リンクカード展開をしっかり待つ
                      urlCount++;
                      
                    } else {
                      // 通常行はバッファに追加（改行も保持）
                      buffer += line + (lineIdx < lines.length - 1 ? '\n' : '');
                    }
                  }
                  
                  // 残りのバッファを貼り付け（空でなければ）
                  if (buffer) {
                    await page.evaluate(async (text) => {
                      await navigator.clipboard.writeText(text);
                    }, buffer);
                    await page.keyboard.press('Control+V');
                    await page.waitForTimeout(100);
                  }
                  
                  if (urlCount > 0) {
                    console.log(`   ℹ️  Processed ${urlCount} URL line(s) with Enter for link cards`);
                  }
                  console.log(`   ✅ Text pasted`);
                } else if (part.type === 'image' && fs.existsSync(part.image.absolutePath)) {
                  console.log(`  📸 Uploading image: ${part.image.localPath}`);
                  
                  // 画像をクリップボードにコピーしてペースト
                  const imageBuffer = fs.readFileSync(part.image.absolutePath);
                  const base64Image = imageBuffer.toString('base64');
                  const mimeType = part.image.absolutePath.endsWith('.png') ? 'image/png' : 
                                   part.image.absolutePath.endsWith('.jpg') || part.image.absolutePath.endsWith('.jpeg') ? 'image/jpeg' : 
                                   'image/gif';
                  
                  await page.evaluate(async ({ base64, mime }) => {
                    const blob = await fetch(`data:${mime};base64,${base64}`).then(r => r.blob());
                    await navigator.clipboard.write([
                      new ClipboardItem({ [mime]: blob })
                    ]);
                  }, { base64: base64Image, mime: mimeType });
                  
                  await page.keyboard.press('Control+V');
                  await page.waitForTimeout(1000);
                  
                  // 画像貼り付け後、改行してテキスト入力モードに戻る
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(300);
                  
                  console.log(`  ✅ Image uploaded: ${part.image.localPath}`);
                }
              }
              console.log('✅ Content with images inserted');
            }
            
            // コンテンツが反映されるまで待機
            console.log('⏳ Waiting for content to be reflected...');
            await page.waitForTimeout(2000);
            
            // 入力内容の最終確認
            const finalTitleValue = await page.locator('textarea[placeholder*="タイトル"]').first().inputValue();
            const finalBodyContent = await page.locator('div[contenteditable="true"][role="textbox"]').first().textContent();
            console.log(`📊 Final check - Title: ${finalTitleValue.length} chars, Body: ${finalBodyContent.length} chars`);

            if (!isPublic) {
              // 下書き保存
              console.log('💾 Saving draft...');
              const saveBtn = page.locator('button:has-text("下書き保存")').first();
              await saveBtn.waitFor({ state: 'visible' });
              
              // 保存前にもう一度待機
              await page.waitForTimeout(1000);
              
              await saveBtn.click();
              
              // 保存完了メッセージを待つ
              await page.locator('text=保存しました').waitFor({ timeout: 10000 }).catch(() => {
                console.log('ℹ️  "保存しました" message not found, but continuing...');
              });
              await page.waitForTimeout(2000);
              
              console.log('✅ Draft saved');
            } else {
              // 公開処理
              const proceedBtn = page.locator('button:has-text("公開に進む")').first();
              await proceedBtn.waitFor({ state: 'visible' });
              await proceedBtn.click();
              await page.waitForTimeout(2000);

              // タグ追加
              if (tags.length > 0) {
                const tagInput = page.locator('input[placeholder*="ハッシュタグ"]').first();
                await tagInput.waitFor({ state: 'visible' });
                for (const tag of tags) {
                  await tagInput.fill(tag);
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(200);
                }
                console.log('✅ Tags added');
              }

              // 投稿
              const publishBtn = page.locator('button:has-text("投稿する")').first();
              await publishBtn.waitFor({ state: 'visible' });
              await publishBtn.click();
              await page.waitForTimeout(5000);
              console.log('✅ Published');
            }

            const finalUrl = page.url();
            console.log('🎉 Success!');
            console.log('   URL:', finalUrl);

            await browser.close();
          }

          main().catch(err => {
            console.error('❌ Error:', err);
            process.exit(1);
          });
          EOFSCRIPT

          echo "✅ Posting script created"

      - name: Execute post to note.com
        run: |
          export MD_FILE="${{ env.MD_FILE }}"
          export THUMBNAIL_PATH="${{ env.THUMBNAIL_PATH }}"
          export POST_TYPE="${{ github.event.inputs.post_type }}"
          
          node ./post-script.mjs

      - name: Upload error screenshot
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: error-screenshot
          path: error-screenshot.png
          if-no-files-found: ignore
          retention-days: 7

      - name: Summary
        if: always()
        run: |
          echo "## 📝 Note Post Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Target Folder | \`${{ github.event.inputs.target_folder }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Post Type | **${{ github.event.inputs.post_type }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Markdown File | \`${{ env.MD_FILE }}\` |" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ env.THUMBNAIL_PATH }}" ]; then
            echo "| Thumbnail | \`${{ env.THUMBNAIL_PATH }}\` |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Thumbnail | None |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Completed at: \`$(date)\`" >> $GITHUB_STEP_SUMMARY
