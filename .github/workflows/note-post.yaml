name: Note Post via MCP

on:
  workflow_dispatch:
    inputs:
      target_folder:
        description: 'ÊäïÁ®ø„Åô„ÇãnoteÈÖç‰∏ã„ÅÆ„Éï„Ç©„É´„ÉÄÂêç (‰æã: exsample)'
        required: true
        type: string
      post_type:
        description: 'ÊäïÁ®ø„Çø„Ç§„Éó'
        required: true
        type: choice
        options:
          - draft
          - publish
        default: draft
      thumbnail_name:
        description: '„Çµ„É†„Éç„Ç§„É´ÁîªÂÉè„Éï„Ç°„Ç§„É´ÂêçÔºà„Éï„Ç©„É´„ÉÄÂÜÖ„ÅÆÁîªÂÉè„ÄÅ‰æã: sample-thumbnail.pngÔºâ'
        required: false
        type: string

jobs:
  post-to-note:
    runs-on: ubuntu-latest
    container: mcr.microsoft.com/playwright:v1.56.1-jammy
    timeout-minutes: 15
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate target folder
        run: |
          TARGET_PATH="note/${{ github.event.inputs.target_folder }}"
          if [ ! -d "$TARGET_PATH" ]; then
            echo "‚ùå Error: Folder $TARGET_PATH does not exist"
            exit 1
          fi
          
          # md„Éï„Ç°„Ç§„É´„ÇíÊé¢„Åô
          MD_FILE=$(find "$TARGET_PATH" -maxdepth 1 -name "*.md" -type f | head -n 1)
          if [ -z "$MD_FILE" ]; then
            echo "‚ùå Error: No markdown file found in $TARGET_PATH"
            exit 1
          fi
          
          echo "‚úÖ Found markdown file: $MD_FILE"
          echo "MD_FILE=$MD_FILE" >> $GITHUB_ENV
          echo "TARGET_PATH=$TARGET_PATH" >> $GITHUB_ENV

      - name: Setup authentication state
        run: |
          echo '${{ secrets.NOTE_STATE_JSON }}' > ~/.note-state.json
          if [ ! -s ~/.note-state.json ]; then
            echo "‚ùå Error: NOTE_STATE_JSON secret is empty"
            echo "Please set NOTE_STATE_JSON secret in repository settings"
            echo "Run 'npm run login' locally to generate the state file"
            exit 1
          fi
          echo "‚úÖ Authentication state file created"

      - name: Determine thumbnail path
        run: |
          if [ -n "${{ github.event.inputs.thumbnail_name }}" ]; then
            THUMBNAIL_PATH="${{ env.TARGET_PATH }}/${{ github.event.inputs.thumbnail_name }}"
            if [ -f "$THUMBNAIL_PATH" ]; then
              echo "THUMBNAIL_PATH=$THUMBNAIL_PATH" >> $GITHUB_ENV
              echo "‚úÖ Using thumbnail: $THUMBNAIL_PATH"
            else
              echo "‚ö†Ô∏è  Warning: Specified thumbnail not found: $THUMBNAIL_PATH"
            fi
          fi

      - name: Install minimal deps
        run: |
          npm i playwright@1.56.1
          echo "‚úÖ Playwright runtime ready (using preinstalled browsers in container)"

      - name: Create posting script
        run: |
          cat > ./post-script.mjs << 'EOFSCRIPT'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import path from 'path';

          // parseMarkdownÈñ¢Êï∞
          function parseMarkdown(content) {
            const lines = content.split('\n');
            let title = '';
            let body = '';
            const tags = [];
            let inFrontMatter = false;
            let frontMatterEnded = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              if (line.trim() === '---') {
                if (!frontMatterEnded) {
                  inFrontMatter = !inFrontMatter;
                  if (!inFrontMatter) {
                    frontMatterEnded = true;
                  }
                  continue;
                }
              }

              if (inFrontMatter) {
                if (line.startsWith('title:')) {
                  title = line.substring(6).trim().replace(/^["']|["']$/g, '');
                } else if (line.startsWith('tags:')) {
                  const tagsStr = line.substring(5).trim();
                  if (tagsStr.startsWith('[') && tagsStr.endsWith(']')) {
                    tags.push(...tagsStr.slice(1, -1).split(',').map(t => t.trim().replace(/^["']|["']$/g, '')));
                  }
                } else if (line.trim().startsWith('-')) {
                  const tag = line.trim().substring(1).trim().replace(/^["']|["']$/g, '');
                  if (tag) tags.push(tag);
                }
                continue;
              }

              if (!title && line.startsWith('# ')) {
                title = line.substring(2).trim();
                continue;
              }

              if (frontMatterEnded || !line.trim().startsWith('---')) {
                body += line + '\n';
              }
            }

            return {
              title: title || 'Untitled',
              body: body.trim(),
              tags: tags.filter(Boolean),
            };
          }

          // ÁîªÂÉèÊäΩÂá∫Èñ¢Êï∞
          function extractImages(markdown, baseDir) {
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            const images = [];
            let match;

            while ((match = imageRegex.exec(markdown)) !== null) {
              const alt = match[1] || 'image';
              const imagePath = match[2];
              
              if (!imagePath.startsWith('http://') && !imagePath.startsWith('https://')) {
                const absolutePath = path.resolve(baseDir, imagePath);
                if (fs.existsSync(absolutePath)) {
                  images.push({
                    alt,
                    localPath: imagePath,
                    absolutePath,
                    placeholder: match[0],
                  });
                }
              }
            }

            return images;
          }

          // „É°„Ç§„É≥Âá¶ÁêÜ
          async function main() {
            const markdownPath = process.env.MD_FILE;
            const thumbnailPath = process.env.THUMBNAIL_PATH || '';
            const isPublic = process.env.POST_TYPE === 'publish';
            const statePath = path.join(process.env.HOME, '.note-state.json');

            console.log('üìù Starting note.com post...');
            console.log('  Markdown:', markdownPath);
            console.log('  Thumbnail:', thumbnailPath || 'None');
            console.log('  Type:', isPublic ? 'Publish' : 'Draft');

            const mdContent = fs.readFileSync(markdownPath, 'utf-8');
            const { title, body, tags } = parseMarkdown(mdContent);
            const baseDir = path.dirname(markdownPath);
            const images = extractImages(body, baseDir);

            console.log('  Title:', title);
            console.log('  Tags:', tags.join(', '));
            console.log('  Images:', images.length);

            const browser = await chromium.launch({
              headless: true,
              args: ['--lang=ja-JP', '--no-sandbox', '--disable-setuid-sandbox'],
            });

            const context = await browser.newContext({
              storageState: statePath,
              locale: 'ja-JP',
              permissions: ['clipboard-read', 'clipboard-write'],
            });

            const page = await context.newPage();
            page.setDefaultTimeout(180000);

            await context.grantPermissions(['clipboard-read', 'clipboard-write'], { 
              origin: 'https://editor.note.com' 
            });

            try {
              console.log('üåê Navigating to editor...');
              await page.goto('https://editor.note.com/new', { 
                waitUntil: 'domcontentloaded',
                timeout: 180000 
              });
              
              console.log('‚è≥ Waiting for editor to load...');
              const titleInputSelectors = [
                'textarea[data-placeholder*="„Çø„Ç§„Éà„É´" i]',
                'input[data-placeholder*="„Çø„Ç§„Éà„É´" i]',
                'textarea[placeholder*="„Çø„Ç§„Éà„É´" i]',
                'input[placeholder*="„Çø„Ç§„Éà„É´" i]',
                'textarea[aria-label*="„Çø„Ç§„Éà„É´" i]',
                'input[aria-label*="„Çø„Ç§„Éà„É´" i]',
                'textarea',
                'input[type="text"]',
              ];

              const titleDisplaySelectors = [
                '[data-placeholder*="„Çø„Ç§„Éà„É´" i]',
                '[aria-placeholder*="„Çø„Ç§„Éà„É´" i]',
                'div[role="textbox"][data-placeholder]',
                'div[role="textbox"]:has-text("Ë®ò‰∫ã„Çø„Ç§„Éà„É´")',
                'div:has-text("Ë®ò‰∫ã„Çø„Ç§„Éà„É´")',
              ];

              const triedInputs = [];
              let titleInputSelectorInDom = '';
              for (const selector of titleInputSelectors) {
                const locator = page.locator(selector).first();
                try {
                  await locator.waitFor({ state: 'attached', timeout: 7000 });
                  const count = await locator.count();
                  if (count > 0) {
                    titleInputSelectorInDom = selector;
                    console.log(`‚úÖ Found title input candidate in DOM: ${selector}`);
                    break;
                  }
                } catch (err) {
                  // ignore and try next
                }
                triedInputs.push(selector);
              }

              if (!titleInputSelectorInDom) {
                throw new Error(`Title input not found. Tried selectors: ${titleInputSelectors.join(', ')}`);
              }

              let titleDisplaySelectorInDom = '';
              for (const selector of titleDisplaySelectors) {
                const locator = page.locator(selector).first();
                try {
                  await locator.waitFor({ state: 'visible', timeout: 7000 });
                  titleDisplaySelectorInDom = selector;
                  console.log(`‚úÖ Found title display field: ${selector}`);
                  break;
                } catch (err) {
                  console.log(`‚ÑπÔ∏è  Display locator not visible yet: ${selector}`);
                }
              }

              if (!titleDisplaySelectorInDom) {
                console.log('‚ö†Ô∏è  Visible title display not found; will rely on input only');
              }

              console.log('‚úÖ Editor loaded successfully');
              page.__titleInputSelector = titleInputSelectorInDom;
              page.__titleDisplaySelector = titleDisplaySelectorInDom;
            } catch (error) {
              console.error('‚ùå Failed to load editor page');
              console.error('Error:', error.message);
              
              // „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„ÇíÊíÆÂΩ±
              const screenshotPath = 'error-screenshot.png';
              await page.screenshot({ path: screenshotPath, fullPage: true });
              console.log(`üì∏ Screenshot saved: ${screenshotPath}`);
              
              // ÁèæÂú®„ÅÆURL„ÇíË°®Á§∫
              console.log('Current URL:', page.url());
              
              // „Éö„Éº„Ç∏„ÅÆ„Çø„Ç§„Éà„É´„ÇíË°®Á§∫
              const pageTitle = await page.title();
              console.log('Page Title:', pageTitle);
              
              await browser.close();
              throw error;
            }

            // „Çµ„É†„Éç„Ç§„É´Âá¶ÁêÜÔºàÁ∞°Áï•ÁâàÔºâ
            if (thumbnailPath && fs.existsSync(thumbnailPath)) {
              console.log('üñºÔ∏è  Uploading thumbnail...');
              try {
                const addBtn = page.locator('button[aria-label="ÁîªÂÉè„ÇíËøΩÂä†"]').first();
                await addBtn.waitFor({ state: 'visible', timeout: 10000 });
                await addBtn.click();

                const uploadBtn = page.locator('button:has-text("ÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ")').first();
                await uploadBtn.waitFor({ state: 'visible', timeout: 10000 });

                const fileInput = page.locator('input[type="file"]').first();
                await fileInput.setInputFiles(thumbnailPath);

                await page.waitForTimeout(2000);

                const dialog = page.locator('div[role="dialog"]');
                const saveBtn = dialog.locator('button:has-text("‰øùÂ≠ò")').first();
                await saveBtn.waitFor({ state: 'visible', timeout: 10000 });
                await page.waitForTimeout(1000);
                await saveBtn.click();
                await page.waitForTimeout(2000);

                console.log('‚úÖ Thumbnail uploaded');
              } catch (err) {
                console.log('‚ö†Ô∏è  Thumbnail upload failed:', err.message);
              }
            }

            // „Çø„Ç§„Éà„É´Ë®≠ÂÆö
            if (page.__titleDisplaySelector) {
              try {
                const displayLocator = page.locator(page.__titleDisplaySelector).first();
                await displayLocator.click({ timeout: 5000 }).catch(() => {});
                await displayLocator.focus().catch(() => {});
              } catch (err) {
                console.log(`‚ÑπÔ∏è  Could not focus display locator ${page.__titleDisplaySelector}: ${err.message}`);
              }
            }

            await page.evaluate(({ selectors, value }) => {
              const candidateSelectors = selectors as string[];
              let input: HTMLInputElement | HTMLTextAreaElement | null = null;
              for (const selector of candidateSelectors) {
                const el = document.querySelector(selector) as HTMLInputElement | HTMLTextAreaElement | null;
                if (el) {
                  input = el;
                  break;
                }
              }
              if (!input) {
                throw new Error('Title input element not found during fill');
              }
              input.focus();
              input.value = value;
              const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(input), 'value');
              if (descriptor && descriptor.set) {
                descriptor.set.call(input, value);
              }
              input.dispatchEvent(new InputEvent('input', { bubbles: true }));
              input.dispatchEvent(new Event('change', { bubbles: true }));
            }, { selectors: [page.__titleInputSelector, '[data-placeholder*="„Çø„Ç§„Éà„É´" i] textarea', 'textarea'], value: title });

            console.log(`‚úÖ Title set via selector: ${page.__titleInputSelector}`);

            // Êú¨ÊñáË®≠ÂÆö
            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible' });
            await bodyBox.click();

            // ÁîªÂÉè„ÇíÂê´„Åæ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅMarkdownÂÖ®‰Ωì„Çí‰∏ÄÊã¨„Åß„ÇØ„É™„ÉÉ„Éó„Éú„Éº„ÉâÁµåÁî±„Åß„Éö„Éº„Çπ„Éà
            if (images.length === 0) {
              console.log('üìã Pasting entire content via clipboard...');
              await page.evaluate(async (text) => {
                await navigator.clipboard.writeText(text);
              }, body);
              await page.keyboard.press('Control+V');
              await page.waitForTimeout(1000);
              console.log('‚úÖ Content pasted');
            } else {
              // ÁîªÂÉè„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅÁîªÂÉè„Éû„Éº„Ç´„Éº„ÅßÂàÜÂâ≤„Åó„Å¶Âá¶ÁêÜ
              console.log(`üìã Processing content with ${images.length} images...`);
              
              // ÁîªÂÉè„ÅÆ‰ΩçÁΩÆ„ÅßÊú¨Êñá„ÇíÂàÜÂâ≤
              const parts = [];
              let lastIndex = 0;
              const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
              let match;
              
              while ((match = imageRegex.exec(body)) !== null) {
                // ÁîªÂÉè„ÅÆÂâç„ÅÆ„ÉÜ„Ç≠„Çπ„Éà
                if (match.index > lastIndex) {
                  parts.push({ type: 'text', content: body.slice(lastIndex, match.index) });
                }
                // ÁîªÂÉè
                const imagePath = match[2];
                const image = images.find(img => img.localPath === imagePath);
                if (image) {
                  parts.push({ type: 'image', image: image });
                }
                lastIndex = match.index + match[0].length;
              }
              
              // ÊúÄÂæå„ÅÆ„ÉÜ„Ç≠„Çπ„Éà
              if (lastIndex < body.length) {
                parts.push({ type: 'text', content: body.slice(lastIndex) });
              }
              
              // ÂêÑ„Éë„Éº„Éà„ÇíÈ†ÜÁï™„Å´ÊåøÂÖ•
              for (const part of parts) {
                if (part.type === 'text' && part.content.trim()) {
                  // „ÉÜ„Ç≠„Çπ„Éà„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„ÉâÁµåÁî±„ÅßÊåøÂÖ•
                  await page.evaluate(async (text) => {
                    await navigator.clipboard.writeText(text);
                  }, part.content);
                  await page.keyboard.press('Control+V');
                  await page.waitForTimeout(300);
                } else if (part.type === 'image' && fs.existsSync(part.image.absolutePath)) {
                  console.log(`  üì∏ Uploading image: ${part.image.localPath}`);
                  
                  // ÁîªÂÉè„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Å¶„Éö„Éº„Çπ„Éà
                  const imageBuffer = fs.readFileSync(part.image.absolutePath);
                  const base64Image = imageBuffer.toString('base64');
                  const mimeType = part.image.absolutePath.endsWith('.png') ? 'image/png' : 
                                   part.image.absolutePath.endsWith('.jpg') || part.image.absolutePath.endsWith('.jpeg') ? 'image/jpeg' : 
                                   'image/gif';
                  
                  await page.evaluate(async ({ base64, mime }) => {
                    const blob = await fetch(`data:${mime};base64,${base64}`).then(r => r.blob());
                    await navigator.clipboard.write([
                      new ClipboardItem({ [mime]: blob })
                    ]);
                  }, { base64: base64Image, mime: mimeType });
                  
                  await page.keyboard.press('Control+V');
                  await page.waitForTimeout(1000);
                  console.log(`  ‚úÖ Image uploaded: ${part.image.localPath}`);
                }
              }
              console.log('‚úÖ Content with images inserted');
            }

            if (!isPublic) {
              // ‰∏ãÊõ∏„Åç‰øùÂ≠ò
              const saveBtn = page.locator('button:has-text("‰∏ãÊõ∏„Åç‰øùÂ≠ò")').first();
              await saveBtn.waitFor({ state: 'visible' });
              await saveBtn.click();
              await page.waitForTimeout(3000);
              console.log('‚úÖ Draft saved');
            } else {
              // ÂÖ¨ÈñãÂá¶ÁêÜ
              const proceedBtn = page.locator('button:has-text("ÂÖ¨Èñã„Å´ÈÄ≤„ÇÄ")').first();
              await proceedBtn.waitFor({ state: 'visible' });
              await proceedBtn.click();
              await page.waitForTimeout(2000);

              // „Çø„Ç∞ËøΩÂä†
              if (tags.length > 0) {
                const tagInput = page.locator('input[placeholder*="„Éè„ÉÉ„Ç∑„É•„Çø„Ç∞"]').first();
                await tagInput.waitFor({ state: 'visible' });
                for (const tag of tags) {
                  await tagInput.fill(tag);
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(200);
                }
                console.log('‚úÖ Tags added');
              }

              // ÊäïÁ®ø
              const publishBtn = page.locator('button:has-text("ÊäïÁ®ø„Åô„Çã")').first();
              await publishBtn.waitFor({ state: 'visible' });
              await publishBtn.click();
              await page.waitForTimeout(5000);
              console.log('‚úÖ Published');
            }

            const finalUrl = page.url();
            console.log('üéâ Success!');
            console.log('   URL:', finalUrl);

            await browser.close();
          }

          main().catch(err => {
            console.error('‚ùå Error:', err);
            process.exit(1);
          });
          EOFSCRIPT

          echo "‚úÖ Posting script created"

      - name: Execute post to note.com
        run: |
          export MD_FILE="${{ env.MD_FILE }}"
          export THUMBNAIL_PATH="${{ env.THUMBNAIL_PATH }}"
          export POST_TYPE="${{ github.event.inputs.post_type }}"
          
          node ./post-script.mjs

      - name: Upload error screenshot
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: error-screenshot
          path: error-screenshot.png
          if-no-files-found: ignore
          retention-days: 7

      - name: Summary
        if: always()
        run: |
          echo "## üìù Note Post Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Target Folder | \`${{ github.event.inputs.target_folder }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Post Type | **${{ github.event.inputs.post_type }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Markdown File | \`${{ env.MD_FILE }}\` |" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ env.THUMBNAIL_PATH }}" ]; then
            echo "| Thumbnail | \`${{ env.THUMBNAIL_PATH }}\` |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Thumbnail | None |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Completed at: \`$(date)\`" >> $GITHUB_STEP_SUMMARY
