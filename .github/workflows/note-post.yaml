name: Note Post via MCP

on:
  workflow_dispatch:
    inputs:
      target_folder:
        description: 'æŠ•ç¨¿ã™ã‚‹noteé…ä¸‹ã®ãƒ•ã‚©ãƒ«ãƒ€å (ä¾‹: exsample)'
        required: true
        type: string
      post_type:
        description: 'æŠ•ç¨¿ã‚¿ã‚¤ãƒ—'
        required: true
        type: choice
        options:
          - draft
          - publish
        default: draft
      thumbnail_name:
        description: 'ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç”»åƒã€ä¾‹: sample-thumbnail.pngï¼‰'
        required: false
        type: string

jobs:
  post-to-note:
    runs-on: ubuntu-latest
    container: mcr.microsoft.com/playwright:v1.56.1-jammy
    timeout-minutes: 15
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate target folder
        run: |
          TARGET_PATH="note/${{ github.event.inputs.target_folder }}"
          if [ ! -d "$TARGET_PATH" ]; then
            echo "âŒ Error: Folder $TARGET_PATH does not exist"
            exit 1
          fi
          
          # mdãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
          MD_FILE=$(find "$TARGET_PATH" -maxdepth 1 -name "*.md" -type f | head -n 1)
          if [ -z "$MD_FILE" ]; then
            echo "âŒ Error: No markdown file found in $TARGET_PATH"
            exit 1
          fi
          
          echo "âœ… Found markdown file: $MD_FILE"
          echo "MD_FILE=$MD_FILE" >> $GITHUB_ENV
          echo "TARGET_PATH=$TARGET_PATH" >> $GITHUB_ENV

      - name: Setup authentication state
        run: |
          echo '${{ secrets.NOTE_STATE_JSON }}' > ~/.note-state.json
          if [ ! -s ~/.note-state.json ]; then
            echo "âŒ Error: NOTE_STATE_JSON secret is empty"
            echo "Please set NOTE_STATE_JSON secret in repository settings"
            echo "Run 'npm run login' locally to generate the state file"
            exit 1
          fi
          echo "âœ… Authentication state file created"

      - name: Determine thumbnail path
        run: |
          if [ -n "${{ github.event.inputs.thumbnail_name }}" ]; then
            THUMBNAIL_PATH="${{ env.TARGET_PATH }}/${{ github.event.inputs.thumbnail_name }}"
            if [ -f "$THUMBNAIL_PATH" ]; then
              echo "THUMBNAIL_PATH=$THUMBNAIL_PATH" >> $GITHUB_ENV
              echo "âœ… Using thumbnail: $THUMBNAIL_PATH"
            else
              echo "âš ï¸  Warning: Specified thumbnail not found: $THUMBNAIL_PATH"
            fi
          fi

      - name: Install minimal deps
        run: |
          npm i playwright@1.56.1
          echo "âœ… Playwright runtime ready (using preinstalled browsers in container)"

      - name: Create posting script
        run: |
          cat > ./post-script.mjs << 'EOFSCRIPT'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import path from 'path';

          // parseMarkdowné–¢æ•°
          function parseMarkdown(content) {
            const lines = content.split('\n');
            let title = '';
            let body = '';
            const tags = [];
            let inFrontMatter = false;
            let frontMatterEnded = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              if (line.trim() === '---') {
                if (!frontMatterEnded) {
                  inFrontMatter = !inFrontMatter;
                  if (!inFrontMatter) {
                    frontMatterEnded = true;
                  }
                  continue;
                }
              }

              if (inFrontMatter) {
                if (line.startsWith('title:')) {
                  title = line.substring(6).trim().replace(/^["']|["']$/g, '');
                } else if (line.startsWith('tags:')) {
                  const tagsStr = line.substring(5).trim();
                  if (tagsStr.startsWith('[') && tagsStr.endsWith(']')) {
                    tags.push(...tagsStr.slice(1, -1).split(',').map(t => t.trim().replace(/^["']|["']$/g, '')));
                  }
                } else if (line.trim().startsWith('-')) {
                  const tag = line.trim().substring(1).trim().replace(/^["']|["']$/g, '');
                  if (tag) tags.push(tag);
                }
                continue;
              }

              if (!title && line.startsWith('# ')) {
                title = line.substring(2).trim();
                continue;
              }

              if (frontMatterEnded || !line.trim().startsWith('---')) {
                body += line + '\n';
              }
            }

            return {
              title: title || 'Untitled',
              body: body.trim(),
              tags: tags.filter(Boolean),
            };
          }

          // ç”»åƒæŠ½å‡ºé–¢æ•°
          function extractImages(markdown, baseDir) {
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            const images = [];
            let match;

            while ((match = imageRegex.exec(markdown)) !== null) {
              const alt = match[1] || 'image';
              const imagePath = match[2];
              
              if (!imagePath.startsWith('http://') && !imagePath.startsWith('https://')) {
                const absolutePath = path.resolve(baseDir, imagePath);
                if (fs.existsSync(absolutePath)) {
                  images.push({
                    alt,
                    localPath: imagePath,
                    absolutePath,
                    placeholder: match[0],
                  });
                }
              }
            }

            return images;
          }

          // ãƒ¡ã‚¤ãƒ³å‡¦ç†
          async function main() {
            const markdownPath = process.env.MD_FILE;
            const thumbnailPath = process.env.THUMBNAIL_PATH || '';
            const isPublic = process.env.POST_TYPE === 'publish';
            const statePath = path.join(process.env.HOME, '.note-state.json');

            console.log('ğŸ“ Starting note.com post...');
            console.log('  Markdown:', markdownPath);
            console.log('  Thumbnail:', thumbnailPath || 'None');
            console.log('  Type:', isPublic ? 'Publish' : 'Draft');

            const mdContent = fs.readFileSync(markdownPath, 'utf-8');
            const { title, body, tags } = parseMarkdown(mdContent);
            const baseDir = path.dirname(markdownPath);
            const images = extractImages(body, baseDir);

            console.log('  Title:', title);
            console.log('  Tags:', tags.join(', '));
            console.log('  Images:', images.length);

            const browser = await chromium.launch({
              headless: true,
              args: [
                '--lang=ja-JP',
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-blink-features=AutomationControlled',
              ],
            });

            const context = await browser.newContext({
              storageState: statePath,
              locale: 'ja-JP',
              permissions: ['clipboard-read', 'clipboard-write'],
              userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
              viewport: { width: 1280, height: 720 },
              deviceScaleFactor: 1,
              isMobile: false,
              hasTouch: false,
            });

            const page = await context.newPage();
            page.setDefaultTimeout(180000);
            
            // Headlessæ¤œçŸ¥ã‚’å›é¿
            await page.addInitScript(() => {
              Object.defineProperty(navigator, 'webdriver', {
                get: () => false,
              });
              // Chromeç‰¹æœ‰ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
              window.chrome = {
                runtime: {},
              };
              // Permissions APIã®ãƒ¢ãƒƒã‚¯
              const originalQuery = window.navigator.permissions.query;
              window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                  Promise.resolve({ state: Notification.permission }) :
                  originalQuery(parameters)
              );
            });

            await context.grantPermissions(['clipboard-read', 'clipboard-write'], { 
              origin: 'https://editor.note.com' 
            });

            // ã¾ãšãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèª
            console.log('ğŸ” Checking authentication status...');
            await page.goto('https://note.com', { waitUntil: 'networkidle' });
            await page.waitForTimeout(2000);
            
            // ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã®ç¢ºèªï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼‰
            const loginCheck = await page.evaluate(() => {
              return {
                hasNotificationIcon: !!document.querySelector('[aria-label*="é€šçŸ¥"]'),
                hasNoteCreateButton: Array.from(document.querySelectorAll('a')).some(a => a.textContent.includes('è¨˜äº‹ã‚’æ›¸ã')),
                hasLoginLink: !!document.querySelector('a[href*="/login"]'),
              };
            });
            
            // é€šçŸ¥ã‚¢ã‚¤ã‚³ãƒ³ãŒã‚ã‚‹ã‹ã€è¨˜äº‹ã‚’æ›¸ããƒœã‚¿ãƒ³ãŒã‚ã‚Œã°ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿
            const isLoggedIn = loginCheck.hasNotificationIcon || loginCheck.hasNoteCreateButton || !loginCheck.hasLoginLink;
            
            console.log(`ğŸ” Login status: ${isLoggedIn ? 'Logged in' : 'Not logged in'}`);
            
            if (!isLoggedIn) {
              throw new Error('Authentication failed. Please check NOTE_STATE_JSON.');
            }
            
            try {
              console.log('ğŸŒ Navigating to editor...');
              await page.goto('https://editor.note.com/new', { 
                waitUntil: 'networkidle',
                timeout: 180000 
              });
              
              console.log('â³ Waiting for editor to load...');
              
              // ã‚ˆã‚Šé•·ã„å¾…æ©Ÿæ™‚é–“ã¨SPAèª­ã¿è¾¼ã¿å¾…æ©Ÿ
              await page.waitForLoadState('networkidle');
              await page.waitForTimeout(5000); // JavaScriptã®å®Ÿè¡Œã‚’å¾…ã¤
              
              // ãƒ‡ãƒãƒƒã‚°: iframeã®ç¢ºèª
              const iframes = await page.locator('iframe').count();
              console.log(`ğŸ” Found ${iframes} iframe(s) on the page`);
              
              // ãƒ‡ãƒãƒƒã‚°: å…¨ã¦ã®textareaã¨inputã‚’ç¢ºèª
              const allTextareas = await page.locator('textarea').count();
              const allInputs = await page.locator('input[type="text"]').count();
              console.log(`ğŸ” Found ${allTextareas} textarea(s) and ${allInputs} text input(s) on the page`);
              
              // contenteditableè¦ç´ ã‚‚ç¢ºèª
              const editableElements = await page.locator('[contenteditable="true"]').count();
              console.log(`ğŸ” Found ${editableElements} contenteditable element(s)`);
              
              const titleInputSelectors = [
                'textarea[placeholder="è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«"]',
                'textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«" i]',
                'input[placeholder="è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«"]',
                'input[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«" i]',
                '[contenteditable="true"][data-placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]',
                '[contenteditable="true"]:first-of-type',
                'textarea',
                'input[type="text"]',
              ];

              let titleInputSelectorInDom = '';
              for (const selector of titleInputSelectors) {
                const locator = page.locator(selector).first();
                try {
                  const count = await locator.count();
                  console.log(`ğŸ” Selector '${selector}' found ${count} element(s)`);
                  
                  if (count > 0) {
                    // è¦ç´ ã®è©³ç´°æƒ…å ±ã‚’å–å¾—
                    const elementInfo = await locator.evaluate(el => ({
                      tagName: el.tagName,
                      placeholder: el.getAttribute('placeholder'),
                      className: el.className,
                      isVisible: el.offsetWidth > 0 && el.offsetHeight > 0,
                      parentVisible: el.parentElement && el.parentElement.offsetWidth > 0,
                    }));
                    console.log(`ğŸ“‹ Element info:`, JSON.stringify(elementInfo));
                    
                    await locator.waitFor({ state: 'visible', timeout: 5000 });
                    titleInputSelectorInDom = selector;
                    console.log(`âœ… Found title input: ${selector}`);
                    break;
                  }
                } catch (err) {
                  console.log(`â„¹ï¸  Error with selector '${selector}': ${err.message}`);
                }
              }

              if (!titleInputSelectorInDom) {
                // ãƒšãƒ¼ã‚¸ã®HTMLã®ä¸€éƒ¨ã‚’å‡ºåŠ›ã—ã¦ãƒ‡ãƒãƒƒã‚°
                const bodyHTML = await page.evaluate(() => {
                  const textareas = Array.from(document.querySelectorAll('textarea'));
                  return textareas.map(ta => ({
                    outerHTML: ta.outerHTML.substring(0, 200),
                    placeholder: ta.placeholder,
                    isVisible: ta.offsetWidth > 0 && ta.offsetHeight > 0,
                  }));
                });
                console.log('ğŸ” All textareas found:', JSON.stringify(bodyHTML, null, 2));
                
                throw new Error(`Title input not found. Tried selectors: ${titleInputSelectors.join(', ')}`);
              }

              console.log('âœ… Editor loaded successfully');
              page.__titleInputSelector = titleInputSelectorInDom;
              page.__titleDisplaySelector = titleInputSelectorInDom;
            } catch (error) {
              console.error('âŒ Failed to load editor page');
              console.error('Error:', error.message);
              
              // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ’®å½±
              const screenshotPath = 'error-screenshot.png';
              await page.screenshot({ path: screenshotPath, fullPage: true });
              console.log(`ğŸ“¸ Screenshot saved: ${screenshotPath}`);
              
              // ç¾åœ¨ã®URLã‚’è¡¨ç¤º
              console.log('Current URL:', page.url());
              
              // ãƒšãƒ¼ã‚¸ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¡¨ç¤º
              const pageTitle = await page.title();
              console.log('Page Title:', pageTitle);
              
              await browser.close();
              throw error;
            }

            // ã‚µãƒ ãƒã‚¤ãƒ«å‡¦ç†ï¼ˆç°¡ç•¥ç‰ˆï¼‰
            if (thumbnailPath && fs.existsSync(thumbnailPath)) {
              console.log('ğŸ–¼ï¸  Uploading thumbnail...');
              try {
                const addBtn = page.locator('button[aria-label="ç”»åƒã‚’è¿½åŠ "]').first();
                await addBtn.waitFor({ state: 'visible', timeout: 10000 });
                await addBtn.click();

                const uploadBtn = page.locator('button:has-text("ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰")').first();
                await uploadBtn.waitFor({ state: 'visible', timeout: 10000 });

                const fileInput = page.locator('input[type="file"]').first();
                await fileInput.setInputFiles(thumbnailPath);

                await page.waitForTimeout(2000);

                const dialog = page.locator('div[role="dialog"]');
                const saveBtn = dialog.locator('button:has-text("ä¿å­˜")').first();
                await saveBtn.waitFor({ state: 'visible', timeout: 10000 });
                await page.waitForTimeout(1000);
                await saveBtn.click();
                await page.waitForTimeout(2000);

                console.log('âœ… Thumbnail uploaded');
              } catch (err) {
                console.log('âš ï¸  Thumbnail upload failed:', err.message);
              }
            }

            // ã‚¿ã‚¤ãƒˆãƒ«è¨­å®š
            await page.evaluate(({ selectors, value }) => {
              const candidateSelectors = Array.isArray(selectors) ? selectors : [];
              let input = null;
              for (const selector of candidateSelectors) {
                const el = document.querySelector(selector);
                if (el) {
                  input = el;
                  break;
                }
              }
              if (!input) {
                throw new Error('Title input element not found during fill');
              }
              if (typeof input.focus === 'function') {
                input.focus();
              }
              const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(input), 'value');
              if (descriptor && typeof descriptor.set === 'function') {
                descriptor.set.call(input, value);
              } else {
                input.value = value;
              }
              input.dispatchEvent(new InputEvent('input', { bubbles: true }));
              input.dispatchEvent(new Event('change', { bubbles: true }));
            }, { selectors: [page.__titleInputSelector, '[data-placeholder*="ã‚¿ã‚¤ãƒˆãƒ«" i] textarea', 'textarea'], value: title });

            console.log(`âœ… Title set via selector: ${page.__titleInputSelector}`);

            // æœ¬æ–‡è¨­å®š
            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible' });
            await bodyBox.click();

            // ç”»åƒã‚’å«ã¾ãªã„å ´åˆã¯ã€Markdownå…¨ä½“ã‚’ä¸€æ‹¬ã§ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰çµŒç”±ã§ãƒšãƒ¼ã‚¹ãƒˆ
            if (images.length === 0) {
              console.log('ğŸ“‹ Pasting entire content via clipboard...');
              await page.evaluate(async (text) => {
                await navigator.clipboard.writeText(text);
              }, body);
              await page.keyboard.press('Control+V');
              await page.waitForTimeout(1000);
              console.log('âœ… Content pasted');
            } else {
              // ç”»åƒãŒã‚ã‚‹å ´åˆã¯ã€ç”»åƒãƒãƒ¼ã‚«ãƒ¼ã§åˆ†å‰²ã—ã¦å‡¦ç†
              console.log(`ğŸ“‹ Processing content with ${images.length} images...`);
              
              // ç”»åƒã®ä½ç½®ã§æœ¬æ–‡ã‚’åˆ†å‰²
              const parts = [];
              let lastIndex = 0;
              const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
              let match;
              
              while ((match = imageRegex.exec(body)) !== null) {
                // ç”»åƒã®å‰ã®ãƒ†ã‚­ã‚¹ãƒˆ
                if (match.index > lastIndex) {
                  parts.push({ type: 'text', content: body.slice(lastIndex, match.index) });
                }
                // ç”»åƒ
                const imagePath = match[2];
                const image = images.find(img => img.localPath === imagePath);
                if (image) {
                  parts.push({ type: 'image', image: image });
                }
                lastIndex = match.index + match[0].length;
              }
              
              // æœ€å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆ
              if (lastIndex < body.length) {
                parts.push({ type: 'text', content: body.slice(lastIndex) });
              }
              
              // å„ãƒ‘ãƒ¼ãƒˆã‚’é †ç•ªã«æŒ¿å…¥
              for (const part of parts) {
                if (part.type === 'text' && part.content.trim()) {
                  // ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰çµŒç”±ã§æŒ¿å…¥
                  await page.evaluate(async (text) => {
                    await navigator.clipboard.writeText(text);
                  }, part.content);
                  await page.keyboard.press('Control+V');
                  await page.waitForTimeout(300);
                } else if (part.type === 'image' && fs.existsSync(part.image.absolutePath)) {
                  console.log(`  ğŸ“¸ Uploading image: ${part.image.localPath}`);
                  
                  // ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãƒšãƒ¼ã‚¹ãƒˆ
                  const imageBuffer = fs.readFileSync(part.image.absolutePath);
                  const base64Image = imageBuffer.toString('base64');
                  const mimeType = part.image.absolutePath.endsWith('.png') ? 'image/png' : 
                                   part.image.absolutePath.endsWith('.jpg') || part.image.absolutePath.endsWith('.jpeg') ? 'image/jpeg' : 
                                   'image/gif';
                  
                  await page.evaluate(async ({ base64, mime }) => {
                    const blob = await fetch(`data:${mime};base64,${base64}`).then(r => r.blob());
                    await navigator.clipboard.write([
                      new ClipboardItem({ [mime]: blob })
                    ]);
                  }, { base64: base64Image, mime: mimeType });
                  
                  await page.keyboard.press('Control+V');
                  await page.waitForTimeout(1000);
                  console.log(`  âœ… Image uploaded: ${part.image.localPath}`);
                }
              }
              console.log('âœ… Content with images inserted');
            }

            if (!isPublic) {
              // ä¸‹æ›¸ãä¿å­˜
              const saveBtn = page.locator('button:has-text("ä¸‹æ›¸ãä¿å­˜")').first();
              await saveBtn.waitFor({ state: 'visible' });
              await saveBtn.click();
              await page.waitForTimeout(3000);
              console.log('âœ… Draft saved');
            } else {
              // å…¬é–‹å‡¦ç†
              const proceedBtn = page.locator('button:has-text("å…¬é–‹ã«é€²ã‚€")').first();
              await proceedBtn.waitFor({ state: 'visible' });
              await proceedBtn.click();
              await page.waitForTimeout(2000);

              // ã‚¿ã‚°è¿½åŠ 
              if (tags.length > 0) {
                const tagInput = page.locator('input[placeholder*="ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°"]').first();
                await tagInput.waitFor({ state: 'visible' });
                for (const tag of tags) {
                  await tagInput.fill(tag);
                  await page.keyboard.press('Enter');
                  await page.waitForTimeout(200);
                }
                console.log('âœ… Tags added');
              }

              // æŠ•ç¨¿
              const publishBtn = page.locator('button:has-text("æŠ•ç¨¿ã™ã‚‹")').first();
              await publishBtn.waitFor({ state: 'visible' });
              await publishBtn.click();
              await page.waitForTimeout(5000);
              console.log('âœ… Published');
            }

            const finalUrl = page.url();
            console.log('ğŸ‰ Success!');
            console.log('   URL:', finalUrl);

            await browser.close();
          }

          main().catch(err => {
            console.error('âŒ Error:', err);
            process.exit(1);
          });
          EOFSCRIPT

          echo "âœ… Posting script created"

      - name: Execute post to note.com
        run: |
          export MD_FILE="${{ env.MD_FILE }}"
          export THUMBNAIL_PATH="${{ env.THUMBNAIL_PATH }}"
          export POST_TYPE="${{ github.event.inputs.post_type }}"
          
          node ./post-script.mjs

      - name: Upload error screenshot
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: error-screenshot
          path: error-screenshot.png
          if-no-files-found: ignore
          retention-days: 7

      - name: Summary
        if: always()
        run: |
          echo "## ğŸ“ Note Post Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Target Folder | \`${{ github.event.inputs.target_folder }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Post Type | **${{ github.event.inputs.post_type }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Markdown File | \`${{ env.MD_FILE }}\` |" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ env.THUMBNAIL_PATH }}" ]; then
            echo "| Thumbnail | \`${{ env.THUMBNAIL_PATH }}\` |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Thumbnail | None |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Completed at: \`$(date)\`" >> $GITHUB_STEP_SUMMARY
